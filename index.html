
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DGPS Points Map</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <!-- Chart.js datalabels plugin for showing sensor X positions -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <!-- jsPDF for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.1/jspdf.plugin.autotable.min.js"></script>
    <!-- SheetJS for Excel generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- html2canvas for chart capture -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        html, body, #map {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        .elev-label {
            font-size: 10px;
            font-weight: bold;
            background: rgba(255,255,255,0.9);
            padding: 2px 4px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }

        .location-label {
            background: rgba(0, 0, 0, 0.8);
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 12px;
            font-weight: bold;
            color: white;
        }

        .legend {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 5px;
            padding: 10px;
            font-size: 12px;
            line-height: 18px;
            color: #555;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
        }

        .legend h4 {
            margin: 0 0 5px;
            color: #777;
        }

        .leaflet-control-layers {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            padding: 10px;
            font-size: 13px;
        }

        .leaflet-control-layers-expanded {
            min-width: 200px;
        }

        .leaflet-control-layers label {
            font-weight: normal;
            margin-bottom: 5px;
            display: block;
        }

        .elevation-toggle {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 5px;
            padding: 8px 12px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            font-size: 12px;
            cursor: pointer;
            user-select: none;
        }

        .elevation-toggle:hover {
            background: rgba(255, 255, 255, 1);
        }

        .elevation-toggle input[type="checkbox"] {
            margin-right: 5px;
        }

        .mobile-controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .control-button {
            background: rgba(255, 255, 255, 0.95);
            border: none;
            border-radius: 5px;
            padding: 8px 12px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            font-size: 11px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.3s;
        }

        .control-button:hover {
            background: rgba(255, 255, 255, 1);
        }

        .control-button.active {
            background: rgba(0, 123, 255, 0.9);
            color: white;
        }

        .measure-controls {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .measure-button {
            background: rgba(255, 255, 255, 0.95);
            border: none;
            border-radius: 5px;
            padding: 8px 12px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            font-size: 11px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.3s;
        }

        .measure-button:hover {
            background: rgba(255, 255, 255, 1);
        }

        .measure-button.active {
            background: rgba(220, 53, 69, 0.9);
            color: white;
        }

        .distance-display {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 5px;
            padding: 8px 12px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            font-size: 12px;
            font-weight: bold;
            color: #333;
        }

        /* Cross-Section Controls */
        .cross-section-controls {
            position: absolute;
            top: 110px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .control-label {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 5px;
            padding: 8px 12px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            font-size: 11px;
            user-select: none;
        }

        .control-label input {
            margin: 0 5px;
        }

        /* Side Panel */
        .side-panel {
            position: fixed;
            right: 0;
            top: 0;
            width: 400px;
            height: 100vh;
            background: rgba(255, 255, 255, 0.98);
            box-shadow: -4px 0 20px rgba(0,0,0,0.3);
            z-index: 1001;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px;
            padding-bottom: 40px;
            box-sizing: border-box;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .side-panel.visible {
            transform: translateX(0);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #ddd;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        .panel-header h3 {
            margin: 0;
            font-size: 18px;
        }

        .panel-info {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 12px;
        }

        .panel-info p {
            margin: 5px 0;
        }

        .chart-container {
            height: 250px;
            margin-bottom: 20px;
            padding-top: 30px;  /* Space for legend above chart */
        }

        .readings-section h4,
        .sensor-section h4 {
            font-size: 14px;
            margin: 15px 0 10px 0;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }

        .table-scroll {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        #readingsTable {
            width: 100%;
            font-size: 9px;
            border-collapse: collapse;
        }

        #readingsTable th {
            background: #f0f0f0;
            padding: 6px 3px;
            text-align: left;
            position: sticky;
            top: 0;
            z-index: 1;
            font-size: 9px;
        }

        #readingsTable td {
            padding: 5px 3px;
            border-bottom: 1px solid #eee;
            white-space: nowrap;
        }

        #readingsTable tr.highlighted {
            background-color: rgba(33, 150, 243, 0.3) !important;
            outline: 2px solid #2196F3;
        }

        #readingsTable tr.disabled-point {
            opacity: 0.5;
            text-decoration: line-through;
        }

        #readingsTable tr {
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #readingsTable tr:hover:not(.highlighted) {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .sensor-section {
            margin-top: 20px;
        }

        .sensor-item {
            background: #e3f2fd;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            border-left: 4px solid #2196F3;
            font-size: 11px;
            position: relative;
        }

        .sensor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .sensor-item .sensor-coords {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }

        .remove-sensor {
            background: #f44336;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 14px;
            line-height: 1;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .edit-sensor {
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 2px 8px;
            font-size: 11px;
            cursor: pointer;
            margin-right: 8px;
        }

        .edit-sensor:hover {
            background: #1976D2;
        }

        .sensor-elev-input {
            width: 80px;
            padding: 2px 4px;
            border: 1px solid #2196F3;
            border-radius: 3px;
            font-size: 11px;
            text-align: center;
        }

        .sensor-elev-display {
            display: flex;
            align-items: center;
            gap: 8px;
            grid-column: 1 / -1;
        }

        #closePanelBtn {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #666;
            line-height: 1;
        }

        #closePanelBtn:hover {
            color: #000;
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal-content {
            background: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-width: 400px;
            width: 90%;
        }

        .modal-content h4 {
            margin: 0 0 15px 0;
        }

        .modal-content p {
            margin: 10px 0;
        }

        .modal-content label {
            display: block;
            margin: 15px 0;
        }

        .modal-content input[type="number"] {
            width: 100%;
            padding: 8px;
            margin-top: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .modal-actions {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .btn-primary {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .btn-primary:hover {
            background: #1976D2;
        }

        .btn-secondary {
            background: #757575;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .btn-secondary:hover {
            background: #616161;
        }

        /* Export/Import Buttons */
        .export-controls {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .export-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .export-btn:hover {
            background: #45a049;
        }

        .export-btn.pdf {
            background: #f44336;
        }

        .export-btn.pdf:hover {
            background: #da190b;
        }

        .export-btn.excel {
            background: #217346;
        }

        .export-btn.excel:hover {
            background: #1a5c38;
        }

        .export-btn.import {
            background: #FF9800;
        }

        .export-btn.import:hover {
            background: #F57C00;
        }

        .export-btn.json {
            background: #2196F3;
        }

        .export-btn.json:hover {
            background: #1976D2;
        }

        #importFileInput {
            display: none;
        }

        /* Image Offset Controls */
        .image-offset-controls {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            gap: 8px;
            align-items: center;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 5px;
            padding: 8px 12px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
        }

        .offset-input-group {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
        }

        .offset-input-group input {
            width: 60px;
            padding: 4px 6px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 11px;
            text-align: center;
        }

        .offset-btn {
            background: rgba(156, 39, 176, 0.9);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 6px 10px;
            font-size: 11px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .offset-btn:hover {
            background: rgba(156, 39, 176, 1);
        }

        .offset-btn.active {
            background: rgba(233, 30, 99, 0.9);
        }

        .offset-btn.reset {
            background: #757575;
        }

        .offset-btn.reset:hover {
            background: #616161;
        }

        /* Reference Line Styles */
        .ref-line-info {
            position: fixed;
            bottom: 100px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-size: 12px;
            z-index: 1000;
            display: none;
        }

        .ref-line-info.visible {
            display: block;
        }

        .ref-line-info p {
            margin: 4px 0;
        }

        .ref-line-info .angle-match {
            color: #4CAF50;
            font-weight: bold;
        }

        .ref-line-info .angle-diff {
            color: #f44336;
            font-weight: bold;
        }

        .control-button.reference {
            background: rgba(255, 152, 0, 0.9);
        }

        .control-button.reference.active {
            background: rgba(230, 81, 0, 0.95);
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="elevation-toggle">
        <label>
            <input type="checkbox" id="elevationToggle" checked>
            Show Elevation Labels
        </label>
    </div>

    <div class="measure-controls">
        <button class="measure-button" id="measureToggle">
            üìè Measure Distance
        </button>
        <button class="measure-button" id="clearMeasure">
            üóëÔ∏è Clear
        </button>
        <div class="distance-display" id="distanceDisplay" style="display: none;">
            Distance: <span id="distanceValue">0</span> m
        </div>
    </div>

    <!-- Cross-Section Controls -->
    <div class="cross-section-controls">
        <button class="control-button" id="crossSectionToggle">
            üìä Cross Section
        </button>
        <label class="control-label">
            Distance: <input type="number" id="perpDistanceInput" value="3" min="0.5" max="100" step="0.5" style="width: 60px;"> m
        </label>
        <button class="control-button" id="addSensorPoint">
            üìç Add Sensor
        </button>
        <button class="control-button reference" id="referenceLineToggle">
            üìê Reference Line
        </button>
        <button class="control-button" id="viewPanelBtn" style="background: rgba(76, 175, 80, 0.9);">
            üìà View Panel
        </button>
        <button class="control-button" id="clearCrossSection">
            üóëÔ∏è Clear
        </button>
    </div>

    <!-- Reference Line Info Display -->
    <div class="ref-line-info" id="refLineInfo">
        <p><strong>üìê Reference vs Cross-Section</strong></p>
        <p>Reference Angle: <span id="refAngle">-</span>¬∞</p>
        <p>Cross-Section Angle: <span id="csAngle">-</span>¬∞</p>
        <p>Difference: <span id="angleDiff">-</span>¬∞</p>
        <button onclick="clearReferenceLine()" style="margin-top: 8px; padding: 4px 10px; cursor: pointer;">Clear Reference</button>
    </div>

    <div class="mobile-controls">
        <button class="control-button" id="layerToggle">
            üìç Maps (Hidden)
        </button>
        <button class="control-button" id="legendToggle">
            üé® Legend (Hidden)
        </button>
    </div>

    <!-- Image Offset Controls -->
    <div class="image-offset-controls">
        <button class="offset-btn" id="imageOffsetToggle">
            üñºÔ∏è Drag Image
        </button>
        <div class="offset-input-group">
            <label>X:</label>
            <input type="number" id="offsetX" value="0" step="0.5">
            <label>m</label>
        </div>
        <div class="offset-input-group">
            <label>Y:</label>
            <input type="number" id="offsetY" value="0" step="0.5">
            <label>m</label>
        </div>
        <button class="offset-btn reset" id="resetOffset">
            ‚Ü∫ Reset
        </button>
    </div>

    <!-- Cross-Section Side Panel -->
    <div id="crossSectionPanel" class="side-panel" style="display: none;">
        <div class="panel-header">
            <h3>Cross Section Profile</h3>
            <button id="closePanelBtn">√ó</button>
        </div>

        <!-- Location and Settings Info -->
        <div class="panel-info">
            <p><strong>Location:</strong> <span id="locationName">-</span></p>
            <p><strong>Length:</strong> <span id="sectionLength">0</span> m</p>
            <p><strong>Points:</strong> <span id="pointCount">0</span></p>
            <p><strong>Perp. Distance:</strong> <span id="currentPerpDist">3</span> m</p>
        </div>

        <!-- Cross Section Chart -->
        <div class="chart-container">
            <canvas id="crossSectionChart"></canvas>
        </div>

        <!-- X and Y Readings Table -->
        <div class="readings-section">
            <h4>Distance & Elevation Readings</h4>
            <div class="table-scroll">
                <table id="readingsTable">
                    <thead>
                        <tr>
                            <th style="width: 30px; text-align: center;">‚úì</th>
                            <th>Point</th>
                            <th>Distance (m)</th>
                            <th>Original Elev (m)</th>
                            <th>Normalized (m)</th>
                            <th>Type</th>
                            <th>UTM X (m)</th>
                            <th>UTM Y (m)</th>
                        </tr>
                    </thead>
                    <tbody id="readingsTableBody">
                        <!-- Populated dynamically -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Sensor Mounting Section -->
        <div class="sensor-section">
            <h4>Velocity cum Level Sensor Mounting</h4>
            <div id="sensorList">
                <!-- Sensor points added dynamically -->
            </div>
        </div>

        <!-- Export/Import Section -->
        <div class="sensor-section">
            <h4>üìÅ Export / Import Profile</h4>
            <div class="export-controls">
                <button class="export-btn json" onclick="exportProfile()">
                    üíæ Export JSON
                </button>
                <button class="export-btn import" onclick="document.getElementById('importFileInput').click()">
                    üìÇ Import JSON
                </button>
                <input type="file" id="importFileInput" accept=".json" onchange="importProfile(event)">
            </div>
            <div class="export-controls" style="margin-top: 10px;">
                <button class="export-btn pdf" onclick="exportToPDF()">
                    üìÑ Export PDF
                </button>
                <button class="export-btn excel" onclick="exportToExcel()">
                    üìä Export Excel
                </button>
            </div>
        </div>
    </div>

    <!-- Elevation Input Modal -->
    <div id="elevationModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h4>Enter Sensor Elevation</h4>
            <p>Location: <span id="modalLatLon">-</span></p>
            <label>
                Elevation (m):
                <input type="number" id="customElevation" step="0.001" placeholder="e.g., 95.500">
            </label>
            <div class="modal-actions">
                <button id="confirmElevation" class="btn-primary">Add Sensor</button>
                <button id="cancelElevation" class="btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.js"></script>

    <script>
        // Register Chart.js datalabels plugin
        if (typeof ChartDataLabels !== 'undefined') {
            Chart.register(ChartDataLabels);
        }

        // Initialize map
       const map = L.map('map', {
    maxZoom: 27
});

// Define multiple map layers
const baseMaps = {
    // Google Maps
    "Google Satellite": L.tileLayer('https://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
        maxZoom: 25,
        subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
        attribution: '&copy; Google Satellite'
    }),
    "Google Hybrid": L.tileLayer('https://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}', {
        maxZoom: 25,
        subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
        attribution: '&copy; Google Hybrid'
    }),
    "Google Streets": L.tileLayer('https://{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
        maxZoom: 25,
        subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
        attribution: '&copy; Google Streets'
    }),
    "Google Terrain": L.tileLayer('https://{s}.google.com/vt/lyrs=p&x={x}&y={y}&z={z}', {
        maxZoom: 25,
        subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
        attribution: '&copy; Google Terrain'
    }),

    // Alternative Satellite Providers (Free)
    "MT1 Satellite": L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
        maxZoom: 20,
        attribution: '&copy; Google Satellite (MT1)'
    }),
    
    // OpenStreetMap
    "OpenStreetMap": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors'
    }),

    // ESRI Maps (High Quality Satellite)
    "ESRI Satellite": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 27,
        attribution: '&copy; ESRI World Imagery'
    }),
    "ESRI Streets": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 19,
        attribution: '&copy; ESRI Street Map'
    }),
    "ESRI Topographic": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 19,
        attribution: '&copy; ESRI Topographic'
    }),

    // Additional High-Quality Sources
   /* "Wikimedia Maps": L.tileLayer('https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}{r}.png', {
        maxZoom: 19,
        attribution: '&copy; Wikimedia Maps'
    }),*/
    "OpenTopoMap": L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
        maxZoom: 17,
        subdomains: 'abc',
        attribution: '&copy; OpenTopoMap'
    }),
    "CyclOSM": L.tileLayer('https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png', {
        maxZoom: 20,
        subdomains: 'abc',
        attribution: '&copy; CyclOSM'
    }),

    // CartoDB
    "CartoDB Positron": L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        maxZoom: 19,
        subdomains: 'abcd',
        attribution: '&copy; CartoDB Positron'
    }),
    "CartoDB Dark": L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        maxZoom: 19,
        subdomains: 'abcd',
        attribution: '&copy; CartoDB Dark Matter'
    }),

   
};

// Add default layer (Google Satellite)
baseMaps["Google Satellite"].addTo(map);

        // UTM to LatLng converter (UTM Zone 43N)
        proj4.defs("EPSG:32643", "+proj=utm +zone=43 +datum=WGS84 +units=m +no_defs");
        const utm43n = proj4("EPSG:32643");
        const wgs84 = proj4("WGS84");

        // Points grouped by location: [y=Northing, x=Easting]
        const locationGroups = {
            "Ajwa Sarovar": [
                { name: "base_1", y: 2478751.89, x: 333247.089, elev: 101.808 },
                { name: "Dami TBM", y: 2478754.274, x: 333253.132, elev: 100 },
                { name: "TBM", y: 2478754.217, x: 333253.124, elev: 100.01 },
                { name: "GL", y: 2478767.34, x: 333230.766, elev: 98.527 },
                { name: "GL", y: 2478768.541, x: 333230.698, elev: 97.511 },
                { name: "GL", y: 2478768.994, x: 333231.603, elev: 97.568 },
                { name: "GL", y: 2478770.436, x: 333232.198, elev: 97.208 },
                { name: "GL", y: 2478774.991, x: 333234.065, elev: 96.769 },
                { name: "GL", y: 2478775.982, x: 333235.195, elev: 96.631 },
                { name: "GL", y: 2478779.29, x: 333236.509, elev: 96.362 },
                { name: "GL", y: 2478781.028, x: 333238.212, elev: 96.187 },
                { name: "GL", y: 2478782.196, x: 333238.507, elev: 96.526 },
                { name: "GL", y: 2478783.461, x: 333239.346, elev: 96.334 },
                { name: "GL", y: 2478784.867, x: 333239.987, elev: 96.118 },
                { name: "GL", y: 2478786.049, x: 333240.255, elev: 95.914 },
                { name: "GL", y: 2478791.572, x: 333242.945, elev: 95.931 },
                { name: "GL", y: 2478798.476, x: 333246.353, elev: 95.926 },
                { name: "GL", y: 2478808.17, x: 333251.102, elev: 95.899 },
                { name: "GL", y: 2478817.91, x: 333255.825, elev: 95.904 },
                { name: "GL", y: 2478828.728, x: 333261.125, elev: 95.923 },
                { name: "GL", y: 2478841.352, x: 333267.22, elev: 95.925 },
                { name: "GL", y: 2478853.15, x: 333272.971, elev: 95.895 },
                { name: "GL", y: 2478869.001, x: 333280.688, elev: 95.929 },
                { name: "GL", y: 2478880.063, x: 333286.149, elev: 95.91 },
                { name: "GL", y: 2478889.086, x: 333290.607, elev: 95.91 },
                { name: "GL", y: 2478898.999, x: 333295.355, elev: 95.928 },
                { name: "GL", y: 2478910.344, x: 333300.886, elev: 95.933 },
                { name: "GL", y: 2478920.929, x: 333306.096, elev: 95.914 },
                { name: "GL", y: 2478931.472, x: 333311.316, elev: 95.913 },
                { name: "GL", y: 2478939.833, x: 333315.363, elev: 95.923 },
                { name: "GL", y: 2478951.024, x: 333320.817, elev: 95.91 },
                { name: "GL", y: 2478959.839, x: 333325.115, elev: 95.913 },
                { name: "GL", y: 2478969.128, x: 333329.602, elev: 95.91 },
                { name: "GL", y: 2478974.03, x: 333332.067, elev: 95.908 },
                { name: "GL", y: 2478978.347, x: 333334.165, elev: 95.924 },
                { name: "GL", y: 2478981.979, x: 333334.857, elev: 96.197 },
                { name: "GL", y: 2478987.451, x: 333338.538, elev: 96.559 },
                { name: "GL", y: 2478992.301, x: 333340.934, elev: 97.066 },
                { name: "GL", y: 2478992.798, x: 333341.42, elev: 97.179 },
                { name: "GL", y: 2478995.725, x: 333342.914, elev: 98.684 },
                { name: "GL", y: 2478997.127, x: 333343.707, elev: 97.961 },
                { name: "GL", y: 2479004.306, x: 333347.85, elev: 98.474 },
                { name: "GL", y: 2478959.392, x: 333358.768, elev: 96.769 },
                { name: "GL", y: 2478809.766, x: 333285.793, elev: 96.685 },
                { name: "GL", y: 2478809.731, x: 333282.732, elev: 95.901 }
            ],
            "Aasoj Feeder": [
                { name: "Aasoj base_1", y: 2485054.594, x: 335648.423, elev: 101.964 },
                { name: "Aasoj TBM", y: 2485048.191, x: 335660.406, elev: 100.000 },
                { name: "Aasoj TBM", y: 2485048.189, x: 335660.409, elev: 100.003 },
                  { name: "Aasoj GL", y: 2485020.180, x: 335624.079, elev: 101.187 },
                { name: "Aasoj GL", y: 2485011.297, x: 335624.962, elev: 100.367 },
                 { name: "Aasoj GL", y: 2485009.452, x: 335628.581, elev: 98.722 },
                { name: "Aasoj GL", y: 2485010.417, x: 335632.578, elev: 96.326 },
                { name: "Aasoj GL", y: 2485009.699, x: 335636.065, elev: 93.902 },
                { name: "Aasoj GL", y: 2485007.973, x: 335642.234, elev: 94.137 },
                { name: "Aasoj GL", y: 2485006.251, x: 335646.958, elev: 94.269 },
                { name: "Aasoj GL", y: 2485005.367, x: 335648.489, elev: 95.931 },
                { name: "Aasoj GL", y: 2485005.114, x: 335649.270, elev: 96.495 },
                { name: "Aasoj GL", y: 2485004.167, x: 335651.677, elev: 98.212 },
        ],
        "Vishwamitri Old Gate": [
                { name: "Aasoj junadarwaja", y: 2485170.123, x: 335606.202, elev: 99.135 },
                { name: "Aasoj junadarwajb", y: 2485170.204, x: 335606.328, elev: 99.139 },
                { name: "Aasoj junadarwajc", y: 2485174.987, x: 335609.519, elev: 95.400 },
                { name: "Aasoj GL", y: 2485175.290, x: 335609.768, elev: 93.601 },
                { name: "Aasoj GL", y: 2485175.648, x: 335610.010, elev: 93.447 },
                { name: "Aasoj GL", y: 2485175.240, x: 335609.684, elev: 95.408 },
                { name: "Aasoj GL", y: 2485184.513, x: 335615.596, elev: 93.474 },
                { name: "Aasoj GL", y: 2485190.927, x: 335619.397, elev: 93.652 },
                { name: "Aasoj GL", y: 2485191.345, x: 335618.738, elev: 95.455 },
                { name: "Aasoj GL", y: 2485194.719, x: 335621.014, elev: 97.805 },
                { name: "Aasoj GL", y: 2485196.183, x: 335621.878, elev: 98.984 },
        ],
        "Vishwamitri Radial": [
            { name: "Rod site pali top", y: 2485116.852, x: 335614.196, elev: 99.932 },
            { name: "Viswamitri Radiyal gav Rod", y: 2485117.323, x: 335611.623, elev: 99.511 },
              { name: "Viswamitri Radiyal gau", y: 2485117.061, x: 335577.132, elev: 95.678 },
              { name: "Viswamitri Radiyal gat", y: 2485117.773, x: 335577.318, elev: 95.665 },
              
                { name: "viswamitri Radil gat", y: 2485129.385, x: 335575.814, elev: 95.987 },
                { name: "viswamitri Radil gau", y: 2485129.552, x: 335574.202, elev: 92.270 },
                { name: "viswamitri Radil gav", y: 2485125.014, x: 335574.446, elev: 92.077 },
                { name: "vise", y: 2485123.540, x: 335574.337, elev: 91.652 },
                { name: "Viswamitri", y: 2485118.487, x: 335569.359, elev: 91.902 },
                { name: "Viswamitrj", y: 2485129.973, x: 335571.321, elev: 92.133 },
              
               
                
            ],
            "Hansapura Waste Weir": [
                { name: "Hansapura base_1", y: 2485806.531, x: 335451.036, elev: 101.578 },
                { name: "Hansapura TBM", y: 2485810.441, x: 335447.992, elev: 100.000 },
                { name: "Hansapura TBM", y: 2485810.433, x: 335447.992, elev: 99.996 },
                { name: "Hansapura GL", y: 2485807.616, x: 335443.252, elev: 97.305 },
                { name: "Hansapura GL", y: 2485807.730, x: 335443.797, elev: 97.411 },
                { name: "Hansapura GL", y: 2485810.142, x: 335447.890, elev: 99.556 },
                { name: "Hansapura GL", y: 2485789.813, x: 335458.847, elev: 99.848 },
                { name: "Hansapura GL", y: 2485787.890, x: 335456.584, elev: 99.839 },
                { name: "Hansapura GL", y: 2485788.286, x: 335456.178, elev: 93.333 },
                { name: "Hansapura GL", y: 2485788.706, x: 335455.944, elev: 92.916 },
                { name: "Hansapura GL", y: 2485790.715, x: 335458.509, elev: 93.408 },
                { name: "Hansapura GL", y: 2485791.091, x: 335458.292, elev: 92.841 },
                { name: "Hansapura GL", y: 2485797.390, x: 335454.600, elev: 92.466 },
                { name: "Hansapura GL", y: 2485795.874, x: 335451.372, elev: 92.392 },
                { name: "Hansapura GL", y: 2485805.074, x: 335450.683, elev: 92.444 },
                { name: "Hansapura GL", y: 2485809.405, x: 335448.537, elev: 92.388 },
                { name: "Hansapura GL", y: 2485806.821, x: 335444.474, elev: 92.462 }
            ],
            "Kodarwaya Bridge": [
                { name: "Kodarwaya base_1", y: 2480158.466, x: 333423.214, elev: 100.935 },
                { name: "Kodarwaya TBM", y: 2480157.193, x: 333421.148, elev: 100.000 },
                { name: "Kodarwaya TBM", y: 2480157.205, x: 333421.143, elev: 100.000 },
                { name: "Kodarwaya TBM", y: 2480158.466, x: 333423.214, elev: 99.346 },
                { name: "Kodarwaya TBM", y: 2480160.240, x: 333423.134, elev: 98.980 },
                { name: "Kodarwaya TBM", y: 2480160.409, x: 333425.139, elev: 98.827 },
                { name: "Kodarwaya TBM", y: 2480160.503, x: 333426.944, elev: 97.833 },
                { name: "Kodarwaya TBM", y: 2480160.070, x: 333434.569, elev: 93.427 },
                { name: "Kodarwaya TBM", y: 2480160.058, x: 333435.445, elev: 92.032 },
                { name: "Kodarwaya TBM", y: 2480160.423, x: 333441.576, elev: 91.678 },
                { name: "Kodarwaya TBM", y: 2480160.265, x: 333446.307, elev: 91.692 },
                { name: "Kodarwaya TBM", y: 2480159.856, x: 333449.281, elev: 91.861 },
                { name: "Kodarwaya TBM", y: 2480159.875, x: 333449.336, elev: 93.536 },
                { name: "Kodarwaya TBM", y: 2480160.510, x: 333453.439, elev: 95.482 },
                { name: "Kodarwaya TBM", y: 2480160.183, x: 333456.675, elev: 97.614 },
                { name: "Kodarwaya TBM", y: 2480158.946, x: 333458.773, elev: 98.758 },
                { name: "Kodarwaya TBM", y: 2480159.966, x: 333461.394, elev: 99.100 },
                { name: "Kodarwaya TBM", y: 2480160.485, x: 333463.659, elev: 99.951 }
            ],
            "Mundhela Waste Weir": [
                { name: "Mundhela base_1", y: 2487772.729, x: 334033.631, elev: 101.789 },
                { name: "Mundhela TBM", y: 2487766.162, x: 334042.016, elev: 100.000 },
                { name: "Mundhela TBM", y: 2487766.332, x: 334042.106, elev: 100.028 },
                { name: "Mundhela TGL", y: 2487768.296, x: 334037.382, elev: 100.017 },
                { name: "Mundhela GL", y: 2487771.078, x: 334031.571, elev: 99.994 },
                { name: "Mundhela GL", y: 2487774.070, x: 334025.425, elev: 100.044 },
                { name: "Mundhela GL", y: 2487778.214, x: 334016.992, elev: 100.042 },
                { name: "Mundhela GL", y: 2487781.819, x: 334009.407, elev: 100.053 },
                { name: "Mundhela GL", y: 2487785.509, x: 334001.825, elev: 100.069 },
                { name: "Mundhela GL", y: 2487789.741, x: 333993.133, elev: 100.025 },
                { name: "Mundhela GL", y: 2487795.032, x: 333982.404, elev: 100.012 },
                { name: "Mundhela GL", y: 2487800.725, x: 333970.193, elev: 99.998 },
                { name: "Mundhela GL", y: 2487806.403, x: 333958.605, elev: 100.078 },
                { name: "Mundhela GL", y: 2487812.419, x: 333946.452, elev: 100.075 },
                { name: "Mundhela GL", y: 2487816.303, x: 333938.357, elev: 100.084 },
                { name: "Mundhela GL", y: 2487818.883, x: 333932.773, elev: 100.014 },
                { name: "Mundhela GL", y: 2487819.150, x: 333932.891, elev: 103.219 },
                { name: "Mundhela GL", y: 2487819.713, x: 333931.995, elev: 103.226 },
                { name: "Mundhela GL", y: 2487806.378, x: 333926.015, elev: 100.516 },
                { name: "Mundhela GL", y: 2487808.970, x: 333927.139, elev: 100.538 },
                { name: "Mundhela GL", y: 2487766.042, x: 334042.576, elev: 103.234 },
                { name: "Mundhela GL", y: 2487765.521, x: 334043.689, elev: 103.242 }
            ],
            "Unjeti Gate": [
                { name: "Unjeti base_1", y: 2482024.595, x: 335423.181, elev: 101.437 },
                { name: "Unjeti TBM", y: 2482018.536, x: 335424.426, elev: 100.000 },
                { name: "Unjeti TBM", y: 2482018.524, x: 335424.428, elev: 100.001 },
                { name: "Unjeti TBM", y: 2482023.116, x: 335408.594, elev: 97.263 },
                { name: "Unjeti TBM", y: 2482043.590, x: 335389.803, elev: 93.285 },
                { name: "Unjeti TBM", y: 2482046.116, x: 335392.339, elev: 93.096 },
                { name: "Unjeti TBM", y: 2482047.701, x: 335393.710, elev: 93.133 },
                { name: "Unjeti TBM", y: 2482049.445, x: 335395.813, elev: 93.108 },
                { name: "Unjeti TBM", y: 2482050.469, x: 335396.924, elev: 93.303 },
                { name: "Unjeti TBM", y: 2482051.961, x: 335395.356, elev: 93.340 },
                { name: "Unjeti TBM", y: 2482050.288, x: 335393.467, elev: 93.357 },
                { name: "Unjeti TBM", y: 2482048.785, x: 335391.741, elev: 93.362 },
                { name: "Unjeti TBM", y: 2482048.536, x: 335391.613, elev: 93.414 },
                { name: "Unjeti TBM", y: 2482047.059, x: 335389.997, elev: 93.418 },
                { name: "Unjeti TBM", y: 2482045.436, x: 335388.164, elev: 93.345 },
                { name: "Unjeti TBM", y: 2482045.290, x: 335388.129, elev: 97.245 },
                { name: "Unjeti TBM", y: 2482044.838, x: 335387.634, elev: 97.242 },
                { name: "Unjeti TBM", y: 2482052.127, x: 335395.668, elev: 97.283 },
                { name: "Unjeti TBM", y: 2482050.042, x: 335398.365, elev: 97.276 },
               
            ],
            "Zoriya Gate": [
                { name: "Zoriya base_1", y: 2483623.133, x: 335464.221, elev: 101.318 },
                { name: "Zoriya TBM", y: 2483623.492, x: 335462.753, elev: 100.000 },
                { name: "Zoriya TBM", y: 2483623.493, x: 335462.751, elev: 100.002 },
                { name: "Zoriya TBM", y: 2483606.174, x: 335493.003, elev: 96.606 },
                { name: "Zoriya RL", y: 2483606.172, x: 335493.003, elev: 96.614 },
                { name: "Zoriya GL", y: 2483606.130, x: 335493.019, elev: 96.605 },
                { name: "Zoriya GL", y: 2483605.777, x: 335500.980, elev: 95.346 },
                { name: "Zoriya GL", y: 2483607.394, x: 335502.424, elev: 94.464 },
                { name: "Zoriya GL", y: 2483609.434, x: 335504.056, elev: 93.236 },
                { name: "Zoriya GL", y: 2483611.146, x: 335505.652, elev: 92.344 },
                { name: "Zoriya GL", y: 2483613.244, x: 335507.598, elev: 91.783 },
                { name: "Zoriya GL", y: 2483615.295, x: 335509.331, elev: 91.212 },
                { name: "Zoriya GL", y: 2483615.802, x: 335509.598, elev: 90.990 },
                { name: "Zoriya GL", y: 2483616.896, x: 335510.738, elev: 91.227 },
                { name: "Zoriya GL", y: 2483617.187, x: 335511.193, elev: 91.795 },
                { name: "Zoriya GL", y: 2483619.475, x: 335513.513, elev: 92.245 },
                { name: "Zoriya GL", y: 2483621.023, x: 335514.912, elev: 93.302 },
                { name: "Zoriya GL", y: 2483623.000, x: 335516.291, elev: 94.770 },
                { name: "Zoriya GL", y: 2483623.534, x: 335516.927, elev: 95.002 }
            ],
            "Narahari_Bridge": [
                { name: "Narahari base_1", y: 2469141.490, x: 313575.913, elev: 101.578 },
                { name: "Narahari TBM", y: 2469142.203, x: 313576.488, elev: 100.002 },
                { name: "Narahari TBM", y: 2469142.194, x: 313576.477, elev: 100.000 },
                { name: "Narahari TBM", y: 2469142.194, x: 313576.479, elev: 100.002 },
                { name: "Narahari Brigade cornar", y: 2469150.687, x: 313552.476, elev: 99.582 },
                { name: "Narahari GL", y: 2469151.363, x: 313553.580, elev: 99.157 },
                { name: "Narahari GL", y: 2469152.654, x: 313552.916, elev: 99.506 },
                { name: "Narahari GL", y: 2469152.085, x: 313554.615, elev: 95.593 },
                { name: "Narahari GL", y: 2469151.046, x: 313559.266, elev: 95.145 },
                { name: "Narahari GL", y: 2469148.865, x: 313565.878, elev: 94.388 },
                { name: "Narahari GL", y: 2469147.468, x: 313569.651, elev: 91.606 },
                { name: "Narahari WATAR top", y: 2469143.862, x: 313572.158, elev: 89.879 },
                { name: "Narahari WATAR top", y: 2469145.245, x: 313573.239, elev: 90.007 },
                { name: "Narahari Brigade secaod cornar", y: 2469150.756, x: 313553.642, elev: 95.473 },
                { name: "Narahari Brigade top", y: 2469149.525, x: 313554.593, elev: 99.490 },
                { name: "Narahari Brigade top", y: 2469145.718, x: 313566.026, elev: 100.012 },
                { name: "Narahari sreet light poll 1", y: 2469145.747, x: 313565.893, elev: 100.017 },
                { name: "Narahari Brigade top", y: 2469141.061, x: 313580.037, elev: 100.010 },
                { name: "Narahari Brigade centar", y: 2469138.959, x: 313586.302, elev: 100.021 },
                { name: "Narahari sreet light poll 2", y: 2469132.905, x: 313604.481, elev: 99.971 },
                { name: "Narahari Brigade top", y: 2469127.723, x: 313618.387, elev: 99.561 },
                { name: "Narahari GL", y: 2469134.845, x: 313602.996, elev: 90.828 },
                { name: "Narahari GL", y: 2469135.328, x: 313604.418, elev: 91.998 },
                { name: "Narahari GL", y: 2469133.971, x: 313608.434, elev: 94.108 },
                { name: "Narahari GL", y: 2469133.054, x: 313612.469, elev: 95.827 },
                { name: "Narahari GL", y: 2469131.627, x: 313615.805, elev: 97.567 },
                { name: "Narahari leval 25", y: 2469140.024, x: 313583.079, elev: 100.030 }
            ],
            "Dena_Bridge": [
                { name: "Dena base_1", y: 2473418.645, x: 315993.593, elev: 101.719 },
                { name: "Dena Dami TBM", y: 2473429.573, x: 315995.303, elev: 100.000 },
                { name: "Dena Dami TBM", y: 2473429.576, x: 315995.304, elev: 99.994 },
                { name: "Dena Dami TBM", y: 2473437.441, x: 315998.570, elev: 99.998 },
                { name: "Dena Dami TBM", y: 2473434.174, x: 316006.431, elev: 99.968 },
                { name: "Dena pillar", y: 2473426.224, x: 316003.181, elev: 99.991 },
                { name: "Dena Watar leval", y: 2473431.480, x: 316033.775, elev: 94.519 },
                { name: "Dena GL", y: 2473435.047, x: 316027.915, elev: 97.825 },
                { name: "Dena GL", y: 2473437.151, x: 316022.510, elev: 97.869 },
                { name: "Dena pillar cornar", y: 2473441.320, x: 316012.980, elev: 98.515 },
                { name: "Dena RL 32.388", y: 2473442.418, x: 316013.314, elev: 98.809 },
                { name: "Dena GL", y: 2473437.250, x: 316009.410, elev: 100.330 },
                { name: "Dena GL", y: 2473441.502, x: 316011.338, elev: 100.778 },
                { name: "Dena GL", y: 2473443.268, x: 316003.636, elev: 103.475 },
                { name: "Dena GL", y: 2473445.585, x: 315999.649, elev: 106.263 },
                { name: "Dena GL", y: 2473449.286, x: 315994.326, elev: 110.914 },
                { name: "Dena Brigade top", y: 2473450.159, x: 315995.582, elev: 111.165 },
                { name: "Dena Brigade top", y: 2473443.427, x: 316011.657, elev: 111.287 },
                { name: "Dena Brigade top", y: 2473433.930, x: 316032.686, elev: 111.326 },
                { name: "Dena Brigade pillar top", y: 2473453.275, x: 316013.128, elev: 112.339 },
                { name: "Dena Brigade pillar top", y: 2473453.171, x: 316013.309, elev: 112.138 },
                { name: "Dena Brigade wol top", y: 2473453.173, x: 316013.317, elev: 112.137 },
                { name: "Dena Brigade wol top", y: 2473448.274, x: 316024.818, elev: 112.153 },
                { name: "Dena Brigade wol top sentar", y: 2473441.889, x: 316039.795, elev: 112.198 },
                { name: "Dena Brigade wol top", y: 2473432.149, x: 316062.704, elev: 112.160 },
                { name: "Dena Brigade wol top", y: 2473426.580, x: 316075.793, elev: 112.133 },
                { name: "Dena Brigade wol top end", y: 2473420.418, x: 316090.497, elev: 111.314 },
                { name: "Dena Brigade wol top end", y: 2473420.544, x: 316090.405, elev: 112.350 },
                { name: "Dena Brigade wol top sentar 2", y: 2473440.982, x: 316041.970, elev: 112.199 },
                { name: "Dena GL", y: 2473459.229, x: 315999.298, elev: 111.498 },
                { name: "Dena near wall", y: 2473451.687, x: 316017.432, elev: 98.534 },
                { name: "Dena near wall", y: 2473451.691, x: 316017.433, elev: 98.515 },
                { name: "Dena GL", y: 2473449.458, x: 316025.895, elev: 98.189 },
                { name: "Dena GL", y: 2473447.304, x: 316029.536, elev: 98.255 },
                { name: "Dena GL", y: 2473445.949, x: 316032.785, elev: 95.918 },
                { name: "Dena Watar leval", y: 2473444.024, x: 316037.129, elev: 94.493 },
                { name: "Dena GL", y: 2473452.082, x: 316016.755, elev: 105.449 },
                { name: "Dena GL", y: 2473466.745, x: 316021.124, elev: 105.515 },
                { name: "Dena GL", y: 2473470.450, x: 316011.882, elev: 110.708 },
                { name: "Dena GL", y: 2473471.937, x: 316007.189, elev: 111.557 },
                { name: "Dena GL", y: 2473456.088, x: 316005.613, elev: 111.348 },
                { name: "Dena GL", y: 2473419.464, x: 316091.634, elev: 111.062 },
                { name: "Dena GL", y: 2473424.446, x: 316083.443, elev: 108.364 },
                { name: "Dena GL", y: 2473428.436, x: 316072.640, elev: 105.765 },
                { name: "Dena GL", y: 2473429.316, x: 316072.515, elev: 105.624 },
                { name: "Dena GL", y: 2473442.272, x: 316078.543, elev: 106.193 },
                { name: "Dena GL", y: 2473437.488, x: 316089.486, elev: 111.012 },
                { name: "Dena GL", y: 2473441.115, x: 316057.875, elev: 97.989 },
                { name: "Dena GL", y: 2473432.687, x: 316057.861, elev: 99.048 },
                { name: "Dena GL", y: 2473448.035, x: 316065.953, elev: 99.890 },
                { name: "Dena GL", y: 2473440.402, x: 316073.269, elev: 101.007 },
                { name: "Dena GL", y: 2473428.462, x: 316071.990, elev: 99.677 },
                { name: "Dena GL", y: 2473440.670, x: 316061.651, elev: 99.335 },
                { name: "Dena Watar leval", y: 2473443.611, x: 316049.632, elev: 94.515 }
            ],
            "Vadsar_Bridge": [
                { name: "Vadsar base_1", y: 2463323.084, x: 311277.813, elev: 101.141 },
                { name: "Vadsar TBM", y: 2463322.390, x: 311277.116, elev: 100.000 },
                { name: "Vadsar TBM", y: 2463322.419, x: 311277.147, elev: 99.992 },
                { name: "Vadsar WATAR top", y: 2463317.528, x: 311291.291, elev: 89.608 },
                { name: "Vadsar GL", y: 2463319.188, x: 311289.389, elev: 89.795 },
                { name: "Vadsar GL", y: 2463322.918, x: 311283.413, elev: 93.236 },
                { name: "Vadsar GL", y: 2463325.022, x: 311277.889, elev: 94.672 },
                { name: "Vadsar GL", y: 2463326.543, x: 311276.392, elev: 96.199 },
                { name: "Vadsar GL", y: 2463328.089, x: 311273.844, elev: 97.014 },
                { name: "Vadsar GL", y: 2463329.333, x: 311271.857, elev: 97.955 },
                { name: "Vadsar Nasurry cornar GL", y: 2463333.296, x: 311263.279, elev: 99.226 },
                { name: "Vadsar Brigade top", y: 2463327.040, x: 311273.138, elev: 100.228 },
                { name: "Vadsar Brigade top", y: 2463320.034, x: 311283.881, elev: 100.224 },
                { name: "Vadsar Brigade center top", y: 2463311.210, x: 311297.352, elev: 100.197 },
                { name: "Vadsar Brigade top", y: 2463304.303, x: 311307.849, elev: 100.221 },
                { name: "Vadsar Brigade top", y: 2463295.875, x: 311320.665, elev: 100.264 },
                { name: "Vadsar WATAR top", y: 2463304.047, x: 311306.924, elev: 89.585 },
                { name: "Vadsar GL", y: 2463303.803, x: 311309.823, elev: 91.257 },
                { name: "Vadsar GL", y: 2463303.118, x: 311311.534, elev: 92.388 },
                { name: "Vadsar GL", y: 2463302.455, x: 311315.165, elev: 94.450 },
                { name: "Vadsar GL", y: 2463299.275, x: 311317.559, elev: 95.082 },
                { name: "Vadsar GL", y: 2463297.685, x: 311318.314, elev: 96.082 },
                { name: "Vadsar GL", y: 2463291.493, x: 311328.370, elev: 98.827 },
                { name: "Vadsar GL", y: 2463289.558, x: 311330.601, elev: 99.465 }
            ]
        };

        // Define colors for each location
        const locationColors = {
            "Ajwa Sarovar": "#FF0000",           // Red
            "Aasoj_Feeder": "#00FF00",           // Green
            "Hansapura_Waste_Weir": "#0000FF",   // Blue
            "Kodarwaya_Bridge": "#FF8000",       // Orange
            "Mundhela_Waste_Weir": "#800080",    // Purple
            "Unjeti_Gate": "#008080",            // Teal
            "Zoriya_Gate": "#FF1493",            // Deep Pink
            "Narahari_Bridge": "#8B4513",        // Saddle Brown
            "Dena_Bridge": "#32CD32",            // Lime Green
            "Vadsar_Bridge": "#FF69B4"           // Hot Pink
        };

        const allBounds = [];
        const allMarkers = []; // Store all markers for elevation toggle

        // Process each location group separately
        Object.keys(locationGroups).forEach(locationName => {
            const points = locationGroups[locationName];
            const color = locationColors[locationName];
            const latlngs = [];

            // Convert points and create markers for this location
            points.forEach(p => {
                const [lon, lat] = proj4(utm43n, wgs84, [p.x, p.y]);

                // Create marker with location-specific color
                const marker = L.circleMarker([lat, lon], {
                    radius: 4,
                    color: color,
                    fillColor: color,
                    fillOpacity: 0.9,
                    weight: 1
                }).addTo(map);

                // Add permanent elevation label
                const elevationTooltip = marker.bindTooltip(`${p.elev} m`, {
                    permanent: true,
                    direction: 'top',
                    className: 'elev-label',
                    offset: [0, -6]
                });

                // Store marker reference for elevation toggle
                allMarkers.push({
                    marker: marker,
                    elevation: p.elev,
                    tooltip: elevationTooltip,
                    pointData: p,
                    locationName: locationName
                });

                // Add detailed popup with location info
                marker.bindPopup(`
                    <strong>${locationName.replace(/_/g, ' ')}</strong><br/>
                    <strong>Point:</strong> ${p.name}<br/>
                    <strong>Elevation:</strong> ${p.elev} m<br/>
                    <strong>Coordinates:</strong><br/>
                    Northing: ${p.y.toFixed(3)} m<br/>
                    Easting: ${p.x.toFixed(3)} m<br/>
                    Lat/Lon: ${lat.toFixed(6)}¬∞, ${lon.toFixed(6)}¬∞
                `);

                latlngs.push([lat, lon]);
                allBounds.push([lat, lon]);
            });

            // Draw polyline connecting points within this location only
            if (latlngs.length > 1) {
                const polyline = L.polyline(latlngs, {
                    color: color,
                    weight: 3,
                    opacity: 0.8
                }).addTo(map);

                // Add location label
                polyline.bindTooltip(locationName.replace(/_/g, ' '), {
                    permanent: true,
                    direction: 'center',
                    className: 'location-label',
                    offset: [0, 0]
                });
            }
        });

        // Create legend
        const legend = L.control({position: 'topright'});
        legend.onAdd = function (map) {
            const div = L.DomUtil.create('div', 'info legend');
            div.innerHTML = '<h4>Survey Locations</h4>';

            Object.keys(locationColors).forEach(location => {
                const color = locationColors[location];
                const displayName = location.replace(/_/g, ' ');
                div.innerHTML +=
                    '<i style="background:' + color + '; width: 18px; height: 18px; display: inline-block; margin-right: 8px;"></i> ' +
                    displayName + '<br>';
            });

            return div;
        };
        // Don't add legend by default - will be added when user clicks toggle

        // Add layer control for switching between different map types
        const layerControl = L.control.layers(baseMaps, null, {
            position: 'topleft',
            collapsed: false
        });
        // Don't add layer control by default - will be added when user clicks toggle

        // Store references for mobile toggle functionality
        let legendVisible = false;
        let layerControlVisible = false;

        // Fit map to show all locations
        if (allBounds.length > 0) {
            map.fitBounds(allBounds);
        }

        // Add elevation toggle functionality
        const elevationToggle = document.getElementById('elevationToggle');
        elevationToggle.addEventListener('change', function() {
            const showElevation = this.checked;

            allMarkers.forEach(markerData => {
                if (showElevation) {
                    // Show elevation tooltip
                    markerData.marker.bindTooltip(`${markerData.elevation} m`, {
                        permanent: true,
                        direction: 'top',
                        className: 'elev-label',
                        offset: [0, -6]
                    });
                } else {
                    // Hide elevation tooltip
                    markerData.marker.unbindTooltip();
                }
            });
        });

        // Distance measurement functionality
        let measureMode = false;
        let measurePoints = [];
        let measureLine = null;
        let measureMarkers = [];

        const measureToggleBtn = document.getElementById('measureToggle');
        const clearMeasureBtn = document.getElementById('clearMeasure');
        const distanceDisplay = document.getElementById('distanceDisplay');
        const distanceValue = document.getElementById('distanceValue');

        // Function to calculate distance between two points using Haversine formula
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // Earth's radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c; // Distance in meters
        }

        // Clear measurement
        function clearMeasurement() {
            measurePoints = [];
            if (measureLine) {
                map.removeLayer(measureLine);
                measureLine = null;
            }
            measureMarkers.forEach(marker => map.removeLayer(marker));
            measureMarkers = [];
            distanceDisplay.style.display = 'none';
        }

        // Measure toggle button
        measureToggleBtn.addEventListener('click', function() {
            measureMode = !measureMode;
            if (measureMode) {
                this.classList.add('active');
                this.innerHTML = 'üìè Measuring...';
                map.getContainer().style.cursor = 'crosshair';
                clearMeasurement();
            } else {
                this.classList.remove('active');
                this.innerHTML = 'üìè Measure Distance';
                map.getContainer().style.cursor = '';
            }
        });

        // Clear button
        clearMeasureBtn.addEventListener('click', function() {
            clearMeasurement();
            if (measureMode) {
                measureToggleBtn.innerHTML = 'üìè Measuring...';
            }
        });

        // Map click handler for measurement
        map.on('click', function(e) {
            if (!measureMode) return;

            const lat = e.latlng.lat;
            const lng = e.latlng.lng;

            // Create draggable marker with custom icon
            const markerIndex = measurePoints.length;
            const icon = L.divIcon({
                className: 'measure-marker-icon',
                html: `<div style="width: 12px; height: 12px; background: #dc3545; border: 2px solid white; border-radius: 50%; box-shadow: 0 2px 5px rgba(0,0,0,0.3);"></div>`,
                iconSize: [12, 12],
                iconAnchor: [6, 6]
            });

            const marker = L.marker([lat, lng], {
                icon: icon,
                draggable: true
            }).addTo(map);

            measureMarkers.push(marker);
            measurePoints.push([lat, lng]);

            if (measurePoints.length === 1) {
                marker.bindTooltip('Start Point', {
                    permanent: true,
                    direction: 'top',
                    className: 'elev-label'
                });
            } else if (measurePoints.length === 2) {
                marker.bindTooltip('End Point', {
                    permanent: true,
                    direction: 'top',
                    className: 'elev-label'
                });

                // Draw line between points
                measureLine = L.polyline(measurePoints, {
                    color: '#dc3545',
                    weight: 3,
                    opacity: 0.8,
                    dashArray: '10, 10'
                }).addTo(map);

                // Calculate and display distance
                updateMeasurementDistance();

                // Reset measure mode
                measureMode = false;
                measureToggleBtn.classList.remove('active');
                measureToggleBtn.innerHTML = 'üìè Measure Distance';
                map.getContainer().style.cursor = '';
            }

            // Add drag handlers
            marker.on('drag', function(e) {
                updateMeasureLineOnDrag();
            });
            
            marker.on('dragend', function(e) {
                const newLatLng = e.target.getLatLng();
                measurePoints[markerIndex] = [newLatLng.lat, newLatLng.lng];
                updateMeasurementDistance();
            });
        });

        // Update measurement line during drag
        function updateMeasureLineOnDrag() {
            if (measureMarkers.length < 2 || !measureLine) return;
            
            const p1 = measureMarkers[0].getLatLng();
            const p2 = measureMarkers[1].getLatLng();
            
            measureLine.setLatLngs([[p1.lat, p1.lng], [p2.lat, p2.lng]]);
            
            // Update distance during drag
            const distance = calculateDistance(p1.lat, p1.lng, p2.lat, p2.lng);
            distanceValue.textContent = distance.toFixed(2);
        }

        // Update measurement distance
        function updateMeasurementDistance() {
            if (measurePoints.length < 2) return;
            
            const distance = calculateDistance(
                measurePoints[0][0], measurePoints[0][1],
                measurePoints[1][0], measurePoints[1][1]
            );
            distanceValue.textContent = distance.toFixed(2);
            distanceDisplay.style.display = 'block';
        }

        // Add mobile control toggle functionality
        const layerToggleBtn = document.getElementById('layerToggle');
        const legendToggleBtn = document.getElementById('legendToggle');

        // Layer control toggle
        layerToggleBtn.addEventListener('click', function() {
            if (layerControlVisible) {
                map.removeControl(layerControl);
                this.classList.remove('active');
                this.innerHTML = 'üìç Maps (Hidden)';
                layerControlVisible = false;
            } else {
                layerControl.addTo(map);
                this.classList.add('active');
                this.innerHTML = 'üìç Maps';
                layerControlVisible = true;
            }
        });

        // Legend toggle
        legendToggleBtn.addEventListener('click', function() {
            if (legendVisible) {
                map.removeControl(legend);
                this.classList.remove('active');
                this.innerHTML = 'üé® Legend (Hidden)';
                legendVisible = false;
            } else {
                legend.addTo(map);
                this.classList.add('active');
                this.innerHTML = 'üé® Legend';
                legendVisible = true;
            }
        });

        // ===== IMAGE OFFSET FUNCTIONALITY =====
        // Allows dragging the map tiles without moving survey points

        let imageOffsetMode = false;
        let imageOffsetX = 0;  // Offset in meters
        let imageOffsetY = 0;  // Offset in meters
        let dragStartLatLng = null;
        let currentTilePane = null;

        const imageOffsetToggle = document.getElementById('imageOffsetToggle');
        const offsetXInput = document.getElementById('offsetX');
        const offsetYInput = document.getElementById('offsetY');
        const resetOffsetBtn = document.getElementById('resetOffset');

        // Get the tile pane for applying transforms
        currentTilePane = map.getPane('tilePane');

        // Toggle image offset mode
        imageOffsetToggle.addEventListener('click', function() {
            imageOffsetMode = !imageOffsetMode;
            
            if (imageOffsetMode) {
                this.classList.add('active');
                this.innerHTML = 'üñºÔ∏è Dragging...';
                map.dragging.disable();
                map.getContainer().style.cursor = 'move';
                
                // Add drag handlers
                map.on('mousedown', onImageDragStart);
                map.on('touchstart', onImageDragStart);
            } else {
                this.classList.remove('active');
                this.innerHTML = 'üñºÔ∏è Drag Image';
                map.dragging.enable();
                map.getContainer().style.cursor = '';
                
                // Remove drag handlers
                map.off('mousedown', onImageDragStart);
                map.off('touchstart', onImageDragStart);
                map.off('mousemove', onImageDrag);
                map.off('touchmove', onImageDrag);
                map.off('mouseup', onImageDragEnd);
                map.off('touchend', onImageDragEnd);
            }
        });

        function onImageDragStart(e) {
            if (!imageOffsetMode) return;
            
            dragStartLatLng = e.latlng;
            
            map.on('mousemove', onImageDrag);
            map.on('touchmove', onImageDrag);
            map.on('mouseup', onImageDragEnd);
            map.on('touchend', onImageDragEnd);
        }

        function onImageDrag(e) {
            if (!imageOffsetMode || !dragStartLatLng) return;
            
            const currentLatLng = e.latlng;
            
            // Calculate offset in meters using the map's current view
            const startPoint = map.latLngToContainerPoint(dragStartLatLng);
            const currentPoint = map.latLngToContainerPoint(currentLatLng);
            
            // Convert pixel difference to meters (approximate)
            const metersPerPixel = getMetersPerPixel();
            const deltaXMeters = (currentPoint.x - startPoint.x) * metersPerPixel;
            const deltaYMeters = -(currentPoint.y - startPoint.y) * metersPerPixel;  // Invert Y
            
            // Update offsets
            const newOffsetX = imageOffsetX + deltaXMeters;
            const newOffsetY = imageOffsetY + deltaYMeters;
            
            // Apply the offset to tile pane
            applyImageOffset(newOffsetX, newOffsetY);
            
            // Update input fields (temporary, during drag)
            offsetXInput.value = newOffsetX.toFixed(1);
            offsetYInput.value = newOffsetY.toFixed(1);
        }

        function onImageDragEnd(e) {
            if (!imageOffsetMode) return;
            
            if (dragStartLatLng && e.latlng) {
                // Calculate final offset
                const startPoint = map.latLngToContainerPoint(dragStartLatLng);
                const endPoint = map.latLngToContainerPoint(e.latlng);
                
                const metersPerPixel = getMetersPerPixel();
                const deltaXMeters = (endPoint.x - startPoint.x) * metersPerPixel;
                const deltaYMeters = -(endPoint.y - startPoint.y) * metersPerPixel;
                
                // Update stored offsets
                imageOffsetX += deltaXMeters;
                imageOffsetY += deltaYMeters;
                
                // Update input fields
                offsetXInput.value = imageOffsetX.toFixed(1);
                offsetYInput.value = imageOffsetY.toFixed(1);
            }
            
            dragStartLatLng = null;
            
            // Remove move handlers but keep mode active
            map.off('mousemove', onImageDrag);
            map.off('touchmove', onImageDrag);
            map.off('mouseup', onImageDragEnd);
            map.off('touchend', onImageDragEnd);
        }

        function getMetersPerPixel() {
            // Calculate meters per pixel at current zoom level and latitude
            const center = map.getCenter();
            const zoom = map.getZoom();
            
            // Earth circumference at equator in meters
            const earthCircumference = 40075016.686;
            
            // Meters per pixel at equator at zoom 0 = earth circumference / 256
            // Adjusted for latitude and zoom level
            const metersPerPixelAtEquator = earthCircumference / 256;
            const latitudeRadians = center.lat * Math.PI / 180;
            const metersPerPixel = metersPerPixelAtEquator * Math.cos(latitudeRadians) / Math.pow(2, zoom);
            
            return metersPerPixel;
        }

        function applyImageOffset(offsetX, offsetY) {
            // Convert meters to pixels
            const metersPerPixel = getMetersPerPixel();
            const pixelOffsetX = offsetX / metersPerPixel;
            const pixelOffsetY = -offsetY / metersPerPixel;  // Invert Y for screen coordinates
            
            // Apply CSS transform to tile pane
            if (currentTilePane) {
                const currentTransform = currentTilePane.style.transform || '';
                // Extract existing translate values if any (from Leaflet's internal transforms)
                const match = currentTransform.match(/translate3d\(([^,]+),\s*([^,]+),\s*([^)]+)\)/);
                
                if (match) {
                    // Leaflet uses translate3d, we need to add our offset
                    const baseX = parseFloat(match[1]);
                    const baseY = parseFloat(match[2]);
                    currentTilePane.style.transform = `translate3d(${baseX + pixelOffsetX}px, ${baseY + pixelOffsetY}px, 0px)`;
                } else {
                    currentTilePane.style.transform = `translate(${pixelOffsetX}px, ${pixelOffsetY}px)`;
                }
            }
        }

        // Manual input handlers
        offsetXInput.addEventListener('change', function() {
            imageOffsetX = parseFloat(this.value) || 0;
            applyImageOffset(imageOffsetX, imageOffsetY);
        });

        offsetYInput.addEventListener('change', function() {
            imageOffsetY = parseFloat(this.value) || 0;
            applyImageOffset(imageOffsetX, imageOffsetY);
        });

        // Reset offset
        resetOffsetBtn.addEventListener('click', function() {
            imageOffsetX = 0;
            imageOffsetY = 0;
            offsetXInput.value = '0';
            offsetYInput.value = '0';
            
            // Reset tile pane transform
            if (currentTilePane) {
                // We need to preserve Leaflet's base transform, just reset our offset
                // Force a redraw by triggering a tiny pan
                map.panBy([0, 0]);
            }
        });

        // Re-apply offset when map moves or zooms
        map.on('moveend zoomend', function() {
            if (imageOffsetX !== 0 || imageOffsetY !== 0) {
                // Small delay to let Leaflet finish its transforms
                setTimeout(() => {
                    applyImageOffset(imageOffsetX, imageOffsetY);
                }, 50);
            }
        });

        // ===== CROSS-SECTION ANALYSIS FUNCTIONALITY =====

        // State Management Variables
        let crossSectionMode = false;
        let crossSectionPoints = [];
        let crossSectionLine = null;
        let crossSectionMarkers = [];
        let projectedPoints = [];
        let selectedLocation = null;
        let sensorPoints = [];
        let perpDistanceThreshold = 3.0;
        let currentChart = null;
        let sensorMarkers = [];
        let highlightedMarkers = [];  // Markers highlighted as part of cross-section
        let manualPointOverrides = {}; // Manual inclusion/exclusion overrides {pointKey: true/false}

        // Reference Line State
        let referenceLineMode = false;
        let referenceLinePoints = [];
        let referenceLine = null;
        let referenceLineMarkers = [];

        // Get control elements
        const crossSectionToggle = document.getElementById('crossSectionToggle');
        const clearCrossSectionBtn = document.getElementById('clearCrossSection');
        const addSensorBtn = document.getElementById('addSensorPoint');
        const perpDistanceInput = document.getElementById('perpDistanceInput');
        const crossSectionPanel = document.getElementById('crossSectionPanel');
        const closePanelBtn = document.getElementById('closePanelBtn');
        const referenceLineToggle = document.getElementById('referenceLineToggle');
        const refLineInfo = document.getElementById('refLineInfo');
        const viewPanelBtn = document.getElementById('viewPanelBtn');

        // View Panel button handler
        viewPanelBtn.addEventListener('click', function() {
            if (crossSectionPoints.length < 2) {
                alert('No cross-section profile exists. Please create a cross-section first by clicking two points on the map.');
                return;
            }
            
            // Show the panel
            crossSectionPanel.style.display = 'block';
            setTimeout(() => {
                crossSectionPanel.classList.add('visible');
            }, 10);
        });

        // Update perpendicular distance threshold when input changes
        perpDistanceInput.addEventListener('change', function() {
            perpDistanceThreshold = parseFloat(this.value) || 3.0;
            document.getElementById('currentPerpDist').textContent = perpDistanceThreshold.toFixed(1);

            // Regenerate cross-section if one exists
            if (crossSectionPoints.length === 2) {
                generateCrossSection();
            }
        });

        // Cross-section toggle handler
        crossSectionToggle.addEventListener('click', function() {
            crossSectionMode = !crossSectionMode;
            if (crossSectionMode) {
                // Disable other modes
                referenceLineMode = false;
                sensorAddMode = false;
                referenceLineToggle.classList.remove('active');
                referenceLineToggle.innerHTML = 'üìê Reference Line';
                addSensorBtn.classList.remove('active');
                addSensorBtn.innerHTML = 'üìç Add Sensor';

                this.classList.add('active');
                this.innerHTML = 'üìä Selecting...';
                map.getContainer().style.cursor = 'crosshair';

                // Close all popups and disable popup opening
                map.closePopup();
                allMarkers.forEach(markerData => {
                    markerData.marker.closePopup();
                    markerData.marker.unbindPopup();
                });
            } else {
                this.classList.remove('active');
                this.innerHTML = 'üìä Cross Section';
                map.getContainer().style.cursor = '';

                // Re-enable popups
                allMarkers.forEach(markerData => {
                    const p = markerData.pointData;
                    const locationName = markerData.locationName;
                    const markerLatlng = markerData.marker.getLatLng();

                    markerData.marker.bindPopup(`
                        <strong>${locationName.replace(/_/g, ' ')}</strong><br/>
                        <strong>Point:</strong> ${p.name}<br/>
                        <strong>Elevation:</strong> ${p.elev} m<br/>
                        <strong>Coordinates:</strong><br/>
                        Northing: ${p.y.toFixed(3)} m<br/>
                        Easting: ${p.x.toFixed(3)} m<br/>
                        Lat/Lon: ${markerLatlng.lat.toFixed(6)}¬∞, ${markerLatlng.lng.toFixed(6)}¬∞
                    `);
                });
            }
        });

        // Clear cross-section button
        clearCrossSectionBtn.addEventListener('click', clearCrossSection);

        function clearCrossSection() {
            crossSectionPoints = [];
            selectedLocation = null;
            projectedPoints = [];
            manualPointOverrides = {};  // Clear manual overrides

            // Remove line and markers
            if (crossSectionLine) {
                map.removeLayer(crossSectionLine);
                crossSectionLine = null;
            }
            crossSectionMarkers.forEach(marker => map.removeLayer(marker));
            crossSectionMarkers = [];

            // Remove highlights
            highlightedMarkers.forEach(highlight => map.removeLayer(highlight));
            highlightedMarkers = [];

            // Clear chart
            if (currentChart) {
                currentChart.destroy();
                currentChart = null;
            }

            // Hide panel
            crossSectionPanel.classList.remove('visible');
            setTimeout(() => {
                crossSectionPanel.style.display = 'none';
            }, 300);

            // Reset mode
            if (crossSectionMode) {
                crossSectionToggle.innerHTML = 'üìä Selecting...';
            }
        }

        // Close panel button
        closePanelBtn.addEventListener('click', function() {
            crossSectionPanel.classList.remove('visible');
            setTimeout(() => {
                crossSectionPanel.style.display = 'none';
            }, 300);
        });

        // Map click handler for cross-section selection
        map.on('click', function(e) {
            if (!crossSectionMode || sensorAddMode || referenceLineMode) return;

            const latlng = e.latlng;

            // Try to find if clicked on existing marker
            let clickedMarkerData = findMarkerAtLocation(latlng);

            if (clickedMarkerData) {
                // Clicked on existing point
                addCrossSectionPoint({
                    x: clickedMarkerData.pointData.x,
                    y: clickedMarkerData.pointData.y,
                    lat: latlng.lat,
                    lng: latlng.lng,
                    existing: true,
                    location: clickedMarkerData.locationName
                });
            } else {
                // Clicked on map - convert to UTM
                const utm = proj4(wgs84, utm43n, [latlng.lng, latlng.lat]);

                // If this is the first point and no location selected, prompt for location
                if (crossSectionPoints.length === 0) {
                    selectedLocation = promptForLocation();
                    if (!selectedLocation) return;
                }

                addCrossSectionPoint({
                    x: utm[0],  // Easting
                    y: utm[1],  // Northing
                    lat: latlng.lat,
                    lng: latlng.lng,
                    existing: false,
                    location: selectedLocation
                });
            }
        });

        function findMarkerAtLocation(latlng) {
            // Find the closest marker to this location
            const threshold = 0.0001; // ~10 meters max search radius
            let closestMarker = null;
            let closestDist = Infinity;

            for (let i = 0; i < allMarkers.length; i++) {
                const marker = allMarkers[i];
                const markerLatlng = marker.marker.getLatLng();

                const dist = Math.sqrt(
                    Math.pow(markerLatlng.lat - latlng.lat, 2) +
                    Math.pow(markerLatlng.lng - latlng.lng, 2)
                );

                if (dist < threshold && dist < closestDist) {
                    closestDist = dist;
                    closestMarker = marker;
                }
            }
            return closestMarker;
        }

        // ===== REFERENCE LINE FUNCTIONALITY =====

        // Reference line toggle handler
        referenceLineToggle.addEventListener('click', function() {
            referenceLineMode = !referenceLineMode;
            
            // Disable other modes when reference line mode is active
            if (referenceLineMode) {
                crossSectionMode = false;
                sensorAddMode = false;
                crossSectionToggle.classList.remove('active');
                crossSectionToggle.innerHTML = 'üìä Cross Section';
                addSensorBtn.classList.remove('active');
                addSensorBtn.innerHTML = 'üìç Add Sensor';
                
                this.classList.add('active');
                this.innerHTML = 'üìê Selecting...';
                map.getContainer().style.cursor = 'crosshair';
            } else {
                this.classList.remove('active');
                this.innerHTML = 'üìê Reference Line';
                map.getContainer().style.cursor = '';
            }
        });

        // Reference line click handler
        map.on('click', function(e) {
            if (!referenceLineMode) return;

            const latlng = e.latlng;
            const utm = proj4(wgs84, utm43n, [latlng.lng, latlng.lat]);

            if (referenceLinePoints.length >= 2) {
                // Clear existing reference line and start new
                clearReferenceLine();
            }

            referenceLinePoints.push({
                lat: latlng.lat,
                lng: latlng.lng,
                x: utm[0],
                y: utm[1]
            });

            // Add draggable marker
            const markerIndex = referenceLinePoints.length - 1;
            const markerColor = markerIndex === 0 ? '#FF9800' : '#E65100';
            
            // Use regular marker with custom icon for dragging support
            const icon = L.divIcon({
                className: 'ref-marker-icon',
                html: `<div style="width: 16px; height: 16px; background: ${markerColor}; border: 2px solid white; border-radius: 50%; box-shadow: 0 2px 5px rgba(0,0,0,0.3);"></div>`,
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
            
            const marker = L.marker([latlng.lat, latlng.lng], {
                icon: icon,
                draggable: true
            }).addTo(map);
            
            marker.bindTooltip(`Ref Point ${markerIndex + 1}`, {
                permanent: true,
                direction: 'top',
                offset: [0, -10]
            });

            marker.on('drag', function(e) {
                updateReferenceLineOnDrag();
            });
            
            marker.on('dragend', function(e) {
                const newLatLng = e.target.getLatLng();
                const utm = proj4(wgs84, utm43n, [newLatLng.lng, newLatLng.lat]);
                referenceLinePoints[markerIndex].lat = newLatLng.lat;
                referenceLinePoints[markerIndex].lng = newLatLng.lng;
                referenceLinePoints[markerIndex].x = utm[0];
                referenceLinePoints[markerIndex].y = utm[1];
                updateAngleComparison();
            });
            
            referenceLineMarkers.push(marker);

            // Draw line when 2 points selected
            if (referenceLinePoints.length === 2) {
                drawReferenceLine();
                referenceLineMode = false;
                referenceLineToggle.classList.remove('active');
                referenceLineToggle.innerHTML = 'üìê Reference Line';
                map.getContainer().style.cursor = '';
            }
        });

        // Update reference line during drag
        function updateReferenceLineOnDrag() {
            if (referenceLineMarkers.length < 2) return;
            
            const p1 = referenceLineMarkers[0].getLatLng();
            const p2 = referenceLineMarkers[1].getLatLng();
            
            if (referenceLine) {
                referenceLine.setLatLngs([[p1.lat, p1.lng], [p2.lat, p2.lng]]);
            }
        }

        function drawReferenceLine() {
            if (referenceLinePoints.length < 2) return;

            const p1 = referenceLinePoints[0];
            const p2 = referenceLinePoints[1];

            // Draw the line
            referenceLine = L.polyline(
                [[p1.lat, p1.lng], [p2.lat, p2.lng]],
                {
                    color: '#FF9800',
                    weight: 3,
                    opacity: 0.8,
                    dashArray: '10, 10'  // Dashed line to distinguish from cross-section
                }
            ).addTo(map);

            // Calculate and show angle comparison
            updateAngleComparison();
        }

        function calculateLineAngle(p1, p2) {
            // Calculate angle in degrees from horizontal (east)
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            let angle = Math.atan2(dy, dx) * (180 / Math.PI);
            // Normalize to 0-180 range (we don't care about direction)
            if (angle < 0) angle += 180;
            if (angle > 180) angle -= 180;
            return angle;
        }

        function updateAngleComparison() {
            if (referenceLinePoints.length < 2) {
                refLineInfo.classList.remove('visible');
                return;
            }

            const refAngle = calculateLineAngle(referenceLinePoints[0], referenceLinePoints[1]);
            document.getElementById('refAngle').textContent = refAngle.toFixed(2);

            if (crossSectionPoints.length === 2) {
                const csAngle = calculateLineAngle(crossSectionPoints[0], crossSectionPoints[1]);
                document.getElementById('csAngle').textContent = csAngle.toFixed(2);

                // Calculate difference (consider parallel lines have 0 or 180 degree difference)
                let diff = Math.abs(refAngle - csAngle);
                if (diff > 90) diff = 180 - diff;
                
                const diffSpan = document.getElementById('angleDiff');
                diffSpan.textContent = diff.toFixed(2);
                
                // Color code the difference
                if (diff < 1) {
                    diffSpan.className = 'angle-match';
                    diffSpan.textContent += ' ‚úì Parallel!';
                } else if (diff < 5) {
                    diffSpan.className = 'angle-match';
                    diffSpan.textContent += ' (Nearly parallel)';
                } else {
                    diffSpan.className = 'angle-diff';
                }
            } else {
                document.getElementById('csAngle').textContent = 'Not set';
                document.getElementById('angleDiff').textContent = '-';
                document.getElementById('angleDiff').className = '';
            }

            refLineInfo.classList.add('visible');
        }

        function clearReferenceLine() {
            // Remove line
            if (referenceLine) {
                map.removeLayer(referenceLine);
                referenceLine = null;
            }

            // Remove markers
            referenceLineMarkers.forEach(marker => map.removeLayer(marker));
            referenceLineMarkers = [];

            // Clear points
            referenceLinePoints = [];

            // Hide info panel
            refLineInfo.classList.remove('visible');
        }

        // Make clearReferenceLine available globally for the button onclick
        window.clearReferenceLine = clearReferenceLine;

        // Update angle comparison when cross-section changes
        const originalGenerateCrossSection = typeof generateCrossSection === 'function' ? generateCrossSection : null;

        function promptForLocation() {
            const locations = Object.keys(locationGroups);
            const selection = prompt('Select location group:\n\n' +
                locations.map((loc, i) => `${i + 1}. ${loc}`).join('\n') +
                '\n\nEnter number:');

            if (selection) {
                const index = parseInt(selection) - 1;
                if (index >= 0 && index < locations.length) {
                    return locations[index];
                }
            }
            return null;
        }

        function addCrossSectionPoint(point) {
            // Validate location consistency
            if (crossSectionPoints.length === 0) {
                selectedLocation = point.location;
            } else if (point.location !== selectedLocation) {
                alert('Please select points from the same location: ' + selectedLocation);
                return;
            }

            if (crossSectionPoints.length >= 2) {
                alert('Cross-section line already defined. Clear to create a new one.');
                return;
            }

            crossSectionPoints.push(point);

            // Add draggable marker
            const markerIndex = crossSectionPoints.length - 1;
            const marker = L.marker([point.lat, point.lng], {
                draggable: true,
                icon: L.divIcon({
                    className: 'cross-section-marker',
                    html: `<div style="background: #FFA726; width: 16px; height: 16px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 5px rgba(0,0,0,0.5);"></div>`,
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                })
            }).addTo(map);

            marker.bindTooltip(crossSectionPoints.length === 1 ? 'Start (drag to move)' : 'End (drag to move)', {
                permanent: true,
                direction: 'top',
                className: 'elev-label',
                offset: [0, -10]
            });

            // Add drag event handler
            marker.on('dragend', function(e) {
                const newLatLng = e.target.getLatLng();
                // Convert to UTM
                const utm = proj4(wgs84, utm43n, [newLatLng.lng, newLatLng.lat]);

                // Update the point
                crossSectionPoints[markerIndex].lat = newLatLng.lat;
                crossSectionPoints[markerIndex].lng = newLatLng.lng;
                crossSectionPoints[markerIndex].x = utm[0];
                crossSectionPoints[markerIndex].y = utm[1];

                // Redraw line and regenerate cross-section
                updateCrossSectionAfterMove();
            });

            crossSectionMarkers.push(marker);

            // If two points selected, draw line and generate cross-section
            if (crossSectionPoints.length === 2) {
                drawCrossSectionLine();
                generateCrossSection();

                // Exit cross-section mode
                crossSectionMode = false;
                crossSectionToggle.classList.remove('active');
                crossSectionToggle.innerHTML = 'üìä Cross Section';
                map.getContainer().style.cursor = '';
            }
        }

        function updateCrossSectionAfterMove() {
            // Remove old line
            if (crossSectionLine) {
                map.removeLayer(crossSectionLine);
            }

            // Redraw line
            drawCrossSectionLine();

            // Regenerate cross-section
            generateCrossSection();
        }

        function drawCrossSectionLine() {
            const latlngs = crossSectionPoints.map(p => [p.lat, p.lng]);

            crossSectionLine = L.polyline(latlngs, {
                color: '#FFA726',
                weight: 4,
                opacity: 0.8,
                dashArray: '10, 10'
            }).addTo(map);
        }

        function generateCrossSection() {
            const p1 = crossSectionPoints[0];
            const p2 = crossSectionPoints[1];

            // Get all points from selected location
            const locationPoints = locationGroups[selectedLocation];
            if (!locationPoints || locationPoints.length === 0) {
                alert('No points found for location: ' + selectedLocation);
                return;
            }

            // Project all points onto line
            projectedPoints = [];

            locationPoints.forEach(point => {
                const projected = projectPointOntoLine(point, p1, p2);
                if (projected.valid) {
                    projectedPoints.push(projected);
                }
            });

            if (projectedPoints.length === 0) {
                alert('No points found within ' + perpDistanceThreshold + ' meters of the cross-section line');
                return;
            }

            // Sort by distance along line
            projectedPoints.sort((a, b) => a.distanceAlong - b.distanceAlong);

            // Normalize elevations
            const minElev = Math.min(...projectedPoints.map(p => p.elevation));
            projectedPoints.forEach(p => {
                p.originalElevation = p.elevation;
                p.normalizedElevation = p.elevation - minElev;
            });

            // Store full list before any filtering for table display
            window.allProjectedPoints = [...projectedPoints];

            // Calculate line length
            const lineLength = Math.sqrt(
                Math.pow(p2.x - p1.x, 2) +
                Math.pow(p2.y - p1.y, 2)
            );

            // Update panel info
            document.getElementById('locationName').textContent = selectedLocation;
            document.getElementById('sectionLength').textContent = lineLength.toFixed(2);
            document.getElementById('pointCount').textContent = projectedPoints.length;

            // Render chart
            renderChart();

            // Populate table
            populateReadingsTable();

            // Highlight points on map
            highlightCrossSectionPoints();

            // Show panel
            crossSectionPanel.style.display = 'block';
            setTimeout(() => {
                crossSectionPanel.classList.add('visible');
            }, 10);

            // Update reference line angle comparison if exists
            if (referenceLinePoints.length === 2) {
                updateAngleComparison();
            }
        }

        function highlightCrossSectionPoints() {
            // Remove previous highlights
            highlightedMarkers.forEach(highlight => map.removeLayer(highlight));
            highlightedMarkers = [];

            // Highlight each projected point
            projectedPoints.forEach(point => {
                // Find the original marker
                const markerData = allMarkers.find(m =>
                    m.pointData.name === point.name &&
                    Math.abs(m.pointData.elev - point.originalElevation) < 0.001
                );

                if (markerData) {
                    const markerLatlng = markerData.marker.getLatLng();
                    const pointKey = `${point.name}_${point.originalElevation.toFixed(3)}`;

                    // Check if manually excluded
                    const isIncluded = manualPointOverrides[pointKey] !== false;

                    // Create highlight circle
                    const highlightCircle = L.circleMarker(markerLatlng, {
                        radius: 10,
                        color: isIncluded ? '#4CAF50' : '#FF5722',
                        fillColor: isIncluded ? '#4CAF50' : '#FF5722',
                        fillOpacity: 0.3,
                        weight: 2,
                        opacity: 0.8
                    }).addTo(map);

                    // Add click handler to toggle inclusion
                    highlightCircle.on('click', function(e) {
                        L.DomEvent.stopPropagation(e);
                        togglePointInclusion(pointKey, point);
                    });

                    // Add tooltip
                    highlightCircle.bindTooltip(
                        `${point.name}<br/>` +
                        `Distance: ${point.distanceAlong.toFixed(2)} m<br/>` +
                        `Perpendicular: ${point.perpendicularDistance.toFixed(2)} m<br/>` +
                        `<em>Click to ${isIncluded ? 'exclude' : 'include'}</em>`,
                        { sticky: true }
                    );

                    highlightedMarkers.push(highlightCircle);
                }
            });
        }

        function togglePointInclusion(pointKey, point) {
            // Toggle the inclusion state
            if (manualPointOverrides[pointKey] === undefined) {
                // First toggle - exclude it
                manualPointOverrides[pointKey] = false;
            } else {
                // Toggle current state
                manualPointOverrides[pointKey] = !manualPointOverrides[pointKey];
            }

            // Update the display
            updateCrossSectionDisplay();
        }

        function updateCrossSectionDisplay() {
            // Filter points based on manual overrides
            const activePoints = projectedPoints.filter(p => {
                const pointKey = `${p.name}_${p.originalElevation.toFixed(3)}`;
                return manualPointOverrides[pointKey] !== false;
            });

            // Recalculate normalized elevations for active points
            if (activePoints.length > 0) {
                const minElev = Math.min(...activePoints.map(p => p.originalElevation));
                activePoints.forEach(p => {
                    p.normalizedElevation = p.originalElevation - minElev;
                });
            }

            // Update point count
            document.getElementById('pointCount').textContent = activePoints.length;

            // Temporarily replace projectedPoints for rendering
            const originalProjectedPoints = projectedPoints;
            projectedPoints = activePoints;

            // Re-render chart and table
            renderChart();
            populateReadingsTable();

            // Restore original
            projectedPoints = originalProjectedPoints;

            // Update highlights
            highlightCrossSectionPoints();
        }

        function projectPointOntoLine(point, lineStart, lineEnd) {
            const dx = lineEnd.x - lineStart.x;
            const dy = lineEnd.y - lineStart.y;
            const lengthSquared = dx * dx + dy * dy;

            // Check for degenerate line
            if (lengthSquared < 1e-6) {
                return { valid: false };
            }

            const px = point.x - lineStart.x;
            const py = point.y - lineStart.y;
            const t = (px * dx + py * dy) / lengthSquared;

            // Projected point
            const projX = lineStart.x + t * dx;
            const projY = lineStart.y + t * dy;

            // Distances
            const distanceAlong = t * Math.sqrt(lengthSquared);
            const perpDist = Math.sqrt(
                Math.pow(point.x - projX, 2) +
                Math.pow(point.y - projY, 2)
            );

            // Validate based on perpendicular distance
            const valid = perpDist <= perpDistanceThreshold;

            return {
                valid: valid,
                name: point.name,
                originalX: point.x,
                originalY: point.y,
                elevation: point.elev,
                distanceAlong: distanceAlong,
                perpendicularDistance: perpDist,
                t: t,
                position: t < 0 ? 'before' : (t > 1 ? 'after' : 'within')
            };
        }

        // Project sensor point onto line - always returns valid projection
        function projectSensorOntoLine(sensor, lineStart, lineEnd) {
            const dx = lineEnd.x - lineStart.x;
            const dy = lineEnd.y - lineStart.y;
            const lengthSquared = dx * dx + dy * dy;
            const lineLength = Math.sqrt(lengthSquared);

            // Check for degenerate line
            if (lengthSquared < 1e-6) {
                return { distanceAlong: 0, perpendicularDistance: 0 };
            }

            const px = sensor.x - lineStart.x;
            const py = sensor.y - lineStart.y;
            const t = (px * dx + py * dy) / lengthSquared;

            // Projected point on the infinite line
            const projX = lineStart.x + t * dx;
            const projY = lineStart.y + t * dy;

            // Distance along the line (can be negative if before start, or > length if after end)
            const distanceAlong = t * lineLength;

            // Perpendicular distance from sensor to line
            const perpDist = Math.sqrt(
                Math.pow(sensor.x - projX, 2) +
                Math.pow(sensor.y - projY, 2)
            );

            return {
                distanceAlong: distanceAlong,
                perpendicularDistance: perpDist,
                t: t,
                projectedX: projX,
                projectedY: projY
            };
        }

        function renderChart() {
            const ctx = document.getElementById('crossSectionChart').getContext('2d');

            // Destroy existing chart
            if (currentChart) {
                currentChart.destroy();
            }

            // Calculate minimum elevation for normalization
            const minElev = projectedPoints.length > 0
                ? Math.min(...projectedPoints.map(p => p.originalElevation))
                : 0;

            // Prepare DGPS data as {x, y} points for linear scale
            const dgpsData = projectedPoints.map(p => ({
                x: p.distanceAlong,
                y: p.normalizedElevation
            }));

            // Prepare datasets - use scatter type for proper x positioning
            const datasets = [{
                label: 'Cross-Section Profile',
                data: dgpsData,
                borderColor: '#2196F3',
                backgroundColor: 'rgba(33, 150, 243, 0.2)',
                fill: true,
                tension: 0.1,
                pointRadius: 4,
                pointHoverRadius: 6,
                showLine: true
            }];

            // Add sensor points if cross-section exists
            if (crossSectionPoints.length === 2 && sensorPoints.length > 0) {
                const p1 = crossSectionPoints[0];
                const p2 = crossSectionPoints[1];

                // Project sensors onto cross-section line
                const sensorData = [];

                sensorPoints.forEach(sensor => {
                    const projected = projectSensorOntoLine(sensor, p1, p2);
                    sensorData.push({
                        x: projected.distanceAlong,
                        y: sensor.elev - minElev
                    });
                });

                if (sensorData.length > 0) {
                    // Add sensor dataset
                    datasets.push({
                        label: 'Sensors',
                        data: sensorData,
                        borderColor: '#FF6B35',
                        backgroundColor: '#FF6B35',
                        pointStyle: 'triangle',
                        pointRadius: 8,
                        pointHoverRadius: 10,
                        showLine: false,
                        type: 'scatter',
                        // Store sensor info for tooltips
                        sensorInfo: sensorPoints.map((sensor, idx) => ({
                            name: sensor.name || 'Custom Sensor',
                            type: sensor.type,
                            elev: sensor.elev,
                            distanceAlong: sensorData[idx].x
                        }))
                    });
                }
            }

            // Store reference to active points for click handler
            const activePointsForChart = [...projectedPoints];
            // Store sensor data for tooltip reference
            const sensorDataForChart = crossSectionPoints.length === 2 ? sensorPoints.map((sensor) => {
                const p1 = crossSectionPoints[0];
                const p2 = crossSectionPoints[1];
                const projected = projectSensorOntoLine(sensor, p1, p2);
                return {
                    name: sensor.name || 'Custom Sensor',
                    type: sensor.type,
                    elev: sensor.elev,
                    distanceAlong: projected.distanceAlong,
                    normalizedElev: sensor.elev - minElev
                };
            }) : [];

            // Create chart - use scatter type for proper linear X axis
            currentChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2,
                    onClick: function(event, elements) {
                        if (elements.length > 0 && elements[0].datasetIndex === 0) {
                            const index = elements[0].index;
                            const point = activePointsForChart[index];
                            if (point) {
                                highlightTableRow(point);
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    // Check if this is sensor dataset (index 1 when sensors exist)
                                    if (context.datasetIndex === 1 && sensorDataForChart.length > 0) {
                                        const sensor = sensorDataForChart[context.dataIndex];
                                        if (sensor) {
                                            return [
                                                `X Position: ${sensor.distanceAlong.toFixed(2)} m`,
                                                `Elevation: ${sensor.elev.toFixed(3)} m`,
                                                `Normalized: ${sensor.normalizedElev.toFixed(3)} m`,
                                                `Type: ${sensor.type}`
                                            ];
                                        }
                                    }
                                    // DGPS point
                                    const point = activePointsForChart[context.dataIndex];
                                    if (!point) return '';
                                    return [
                                        `X Position: ${point.distanceAlong.toFixed(2)} m`,
                                        `Elevation: ${point.originalElevation.toFixed(3)} m`,
                                        `Normalized: ${point.normalizedElevation.toFixed(3)} m`,
                                        `Perpendicular: ${point.perpendicularDistance.toFixed(2)} m`
                                    ];
                                },
                                title: function(context) {
                                    // Check if this is sensor dataset
                                    if (context[0].datasetIndex === 1 && sensorDataForChart.length > 0) {
                                        const sensor = sensorDataForChart[context[0].dataIndex];
                                        if (sensor) {
                                            return `üî∫ ${sensor.name}`;
                                        }
                                    }
                                    const point = activePointsForChart[context[0].dataIndex];
                                    if (!point) return '';
                                    return `${point.name} (${point.distanceAlong.toFixed(2)} m from start)`;
                                }
                            }
                        },
                        legend: {
                            display: true,
                            position: 'top',
                            align: 'start',
                            labels: {
                                padding: 15,
                                boxWidth: 15,
                                generateLabels: function(chart) {
                                    return [
                                        { text: 'Cross-Section Profile', fillStyle: '#2196F3', strokeStyle: '#2196F3', lineWidth: 2 },
                                        { text: 'Sensor Points', fillStyle: '#FF6B35', strokeStyle: '#FF6B35', pointStyle: 'triangle' }
                                    ];
                                }
                            }
                        },
                        // Configure datalabels plugin
                        datalabels: {
                            display: function(context) {
                                // Only show labels for sensor dataset (index 1)
                                return context.datasetIndex === 1;
                            },
                            align: 'top',
                            anchor: 'end',
                            offset: 4,
                            color: '#FF6B35',
                            font: {
                                weight: 'bold',
                                size: 11
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.8)',
                            borderRadius: 3,
                            padding: { top: 2, bottom: 2, left: 4, right: 4 },
                            formatter: function(value, context) {
                                return `X: ${value.x.toFixed(2)}m`;
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Distance from Start (m)'
                            },
                            beginAtZero: true
                        },
                        y: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Normalized Elevation (m)'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Function to highlight a table row when point is selected from chart
        function highlightTableRow(point) {
            const tbody = document.getElementById('readingsTableBody');
            const rows = tbody.getElementsByTagName('tr');
            const pointKey = `${point.name}_${point.originalElevation.toFixed(3)}`;

            // Remove previous highlights
            for (let row of rows) {
                row.classList.remove('highlighted');
            }

            // Find and highlight the matching row
            for (let row of rows) {
                if (row.dataset.pointKey === pointKey) {
                    row.classList.add('highlighted');
                    // Scroll the row into view
                    row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    break;
                }
            }

            // Also highlight on map
            highlightPointOnMap(point);
        }

        // Function to highlight point on map when selected from chart or table
        function highlightPointOnMap(point) {
            // Find the highlight marker for this point and pulse it
            const pointKey = `${point.name}_${point.originalElevation.toFixed(3)}`;
            
            highlightedMarkers.forEach((marker, idx) => {
                const markerPoint = window.allProjectedPoints[idx];
                if (markerPoint) {
                    const markerKey = `${markerPoint.name}_${markerPoint.originalElevation.toFixed(3)}`;
                    if (markerKey === pointKey) {
                        // Pulse effect - temporarily increase size
                        marker.setRadius(15);
                        setTimeout(() => {
                            const isIncluded = manualPointOverrides[pointKey] !== false;
                            marker.setRadius(10);
                        }, 500);
                    }
                }
            });
        }

        function populateReadingsTable() {
            const tbody = document.getElementById('readingsTableBody');
            tbody.innerHTML = '';

            // Get the full list of projected points (stored globally, not filtered)
            const allProjectedPoints = window.allProjectedPoints || projectedPoints;

            // Calculate minimum elevation for normalization (from active points only)
            const activePoints = allProjectedPoints.filter(p => {
                const pointKey = `${p.name}_${p.originalElevation.toFixed(3)}`;
                return manualPointOverrides[pointKey] !== false;
            });

            const minElev = activePoints.length > 0
                ? Math.min(...activePoints.map(p => p.originalElevation))
                : (allProjectedPoints.length > 0 ? Math.min(...allProjectedPoints.map(p => p.originalElevation)) : 0);

            // Add DGPS points (show ALL points, not just active ones)
            allProjectedPoints.forEach((point, index) => {
                const pointKey = `${point.name}_${point.originalElevation.toFixed(3)}`;
                const isIncluded = manualPointOverrides[pointKey] !== false;

                const row = tbody.insertRow();
                row.dataset.pointKey = pointKey;  // Store point key for lookup
                row.dataset.pointIndex = index;

                // Checkbox column
                const checkboxCell = row.insertCell(0);
                checkboxCell.style.textAlign = 'center';
                checkboxCell.innerHTML = `<input type="checkbox" ${isIncluded ? 'checked' : ''}
                    onchange="event.stopPropagation(); togglePointFromTable('${pointKey}')"
                    style="cursor: pointer; width: 14px; height: 14px;">`;

                // Apply styling for excluded points
                if (!isIncluded) {
                    row.classList.add('disabled-point');
                }

                // Add click handler to highlight on chart and map
                row.onclick = function(e) {
                    if (e.target.type !== 'checkbox') {
                        selectPointFromTable(point, index);
                    }
                };

                row.insertCell(1).textContent = point.name;
                row.insertCell(2).textContent = point.distanceAlong.toFixed(2);
                row.insertCell(3).textContent = point.originalElevation.toFixed(3);
                row.insertCell(4).textContent = (point.originalElevation - minElev).toFixed(3);
                row.insertCell(5).textContent = 'DGPS';  // Type
                row.insertCell(6).textContent = point.originalX ? point.originalX.toFixed(3) : '-';  // UTM X
                row.insertCell(7).textContent = point.originalY ? point.originalY.toFixed(3) : '-';  // UTM Y
            });

            // Add sensor points
            if (crossSectionPoints.length === 2 && sensorPoints.length > 0) {
                const p1 = crossSectionPoints[0];
                const p2 = crossSectionPoints[1];

                sensorPoints.forEach((sensor, idx) => {
                    const projected = projectSensorOntoLine(sensor, p1, p2);
                    const row = tbody.insertRow();
                    const sensorName = sensor.type === 'existing' ? sensor.name : 'Custom Sensor';

                    // Checkbox column (empty for sensors - they can't be toggled)
                    const checkboxCell = row.insertCell(0);
                    checkboxCell.style.textAlign = 'center';
                    checkboxCell.innerHTML = `<span style="color: #FF6B35;">üî∫</span>`;

                    row.insertCell(1).innerHTML = `<strong style="color: #FF6B35;">${sensorName}</strong>`;
                    row.insertCell(2).textContent = projected.distanceAlong.toFixed(2);
                    row.insertCell(3).textContent = sensor.elev.toFixed(3);
                    row.insertCell(4).textContent = (sensor.elev - minElev).toFixed(3);
                    row.insertCell(5).textContent = 'Sensor';
                    row.insertCell(6).textContent = sensor.x.toFixed(3);
                    row.insertCell(7).textContent = sensor.y.toFixed(3);

                    // Highlight sensor rows
                    row.style.backgroundColor = 'rgba(255, 107, 53, 0.1)';
                });
            }
        }

        // Global function for toggling points from table checkboxes
        window.togglePointFromTable = function(pointKey) {
            // Toggle the point
            if (manualPointOverrides[pointKey] === undefined) {
                manualPointOverrides[pointKey] = false;
            } else {
                manualPointOverrides[pointKey] = !manualPointOverrides[pointKey];
            }

            // Update all displays (chart, table, map)
            updateCrossSectionDisplay();
        };

        // Function to select a point from table and highlight on chart and map
        function selectPointFromTable(point, index) {
            const tbody = document.getElementById('readingsTableBody');
            const rows = tbody.getElementsByTagName('tr');
            const pointKey = `${point.name}_${point.originalElevation.toFixed(3)}`;

            // Remove previous highlights from table
            for (let row of rows) {
                row.classList.remove('highlighted');
            }

            // Highlight clicked row
            for (let row of rows) {
                if (row.dataset.pointKey === pointKey) {
                    row.classList.add('highlighted');
                    break;
                }
            }

            // Highlight on map
            highlightPointOnMap(point);

            // Highlight on chart - find the point index in active points
            const isIncluded = manualPointOverrides[pointKey] !== false;
            if (isIncluded && currentChart) {
                const activePoints = (window.allProjectedPoints || []).filter(p => {
                    const pKey = `${p.name}_${p.originalElevation.toFixed(3)}`;
                    return manualPointOverrides[pKey] !== false;
                });
                
                const chartIndex = activePoints.findIndex(p => 
                    p.name === point.name && 
                    Math.abs(p.originalElevation - point.originalElevation) < 0.001
                );

                if (chartIndex >= 0) {
                    // Highlight point on chart
                    currentChart.setActiveElements([{
                        datasetIndex: 0,
                        index: chartIndex
                    }]);
                    currentChart.update();
                }
            }
        }

        // ===== SENSOR POINT ADDITION FUNCTIONALITY =====

        let sensorAddMode = false;
        let pendingElevationData = null;

        addSensorBtn.addEventListener('click', function() {
            sensorAddMode = !sensorAddMode;
            if (sensorAddMode) {
                this.classList.add('active');
                this.innerHTML = 'üìç Click to Add...';
                map.getContainer().style.cursor = 'crosshair';

                // Close all popups and disable popup opening
                map.closePopup();
                allMarkers.forEach(markerData => {
                    markerData.marker.closePopup();
                    markerData.marker.unbindPopup();
                });
            } else {
                this.classList.remove('active');
                this.innerHTML = 'üìç Add Sensor';
                map.getContainer().style.cursor = '';

                // Re-enable popups (only if not in cross-section mode)
                if (!crossSectionMode) {
                    allMarkers.forEach(markerData => {
                        const p = markerData.pointData;
                        const locationName = markerData.locationName;
                        const markerLatlng = markerData.marker.getLatLng();

                        markerData.marker.bindPopup(`
                            <strong>${locationName.replace(/_/g, ' ')}</strong><br/>
                            <strong>Point:</strong> ${p.name}<br/>
                            <strong>Elevation:</strong> ${p.elev} m<br/>
                            <strong>Coordinates:</strong><br/>
                            Northing: ${p.y.toFixed(3)} m<br/>
                            Easting: ${p.x.toFixed(3)} m<br/>
                            Lat/Lon: ${markerLatlng.lat.toFixed(6)}¬∞, ${markerLatlng.lng.toFixed(6)}¬∞
                        `);
                    });
                }
            }
        });

        // Sensor addition via map click
        map.on('click', function(e) {
            if (!sensorAddMode || crossSectionMode) return;

            const latlng = e.latlng;
            
            // Always use the actual clicked location coordinates
            // Convert clicked lat/lng to UTM for x, y
            const utm = proj4(wgs84, utm43n, [latlng.lng, latlng.lat]);
            const clickedX = utm[0];
            const clickedY = utm[1];
            
            // Check if there's a nearby marker to get elevation and name from
            let clickedMarkerData = findMarkerAtLocation(latlng);

            if (clickedMarkerData) {
                // Method A: Use elevation and name from nearby point, but actual clicked coordinates
                addSensorPoint({
                    name: clickedMarkerData.pointData.name,
                    x: clickedX,  // Use actual clicked UTM coordinates
                    y: clickedY,  // Use actual clicked UTM coordinates
                    elev: clickedMarkerData.pointData.elev,
                    lat: latlng.lat,
                    lon: latlng.lng,
                    location: clickedMarkerData.locationName,
                    type: 'existing'
                });
            } else {
                // Method B: Custom location - prompt for elevation
                promptForElevation(clickedX, clickedY, latlng.lat, latlng.lng);
            }
        });

        function promptForElevation(x, y, lat, lon) {
            pendingElevationData = { x, y, lat, lon };
            document.getElementById('modalLatLon').textContent = `${lat.toFixed(6)}¬∞, ${lon.toFixed(6)}¬∞`;
            document.getElementById('elevationModal').style.display = 'flex';
        }

        document.getElementById('confirmElevation').addEventListener('click', function() {
            const elev = parseFloat(document.getElementById('customElevation').value);
            if (isNaN(elev)) {
                alert('Please enter a valid elevation value');
                return;
            }

            addSensorPoint({
                name: 'Custom Sensor Point',
                x: pendingElevationData.x,
                y: pendingElevationData.y,
                elev: elev,
                lat: pendingElevationData.lat,
                lon: pendingElevationData.lon,
                location: selectedLocation || 'Custom',
                type: 'custom'
            });

            document.getElementById('elevationModal').style.display = 'none';
            document.getElementById('customElevation').value = '';
            pendingElevationData = null;
        });

        document.getElementById('cancelElevation').addEventListener('click', function() {
            document.getElementById('elevationModal').style.display = 'none';
            document.getElementById('customElevation').value = '';
            pendingElevationData = null;

            // Exit sensor add mode and re-enable popups
            sensorAddMode = false;
            addSensorBtn.classList.remove('active');
            addSensorBtn.innerHTML = 'üìç Add Sensor';
            map.getContainer().style.cursor = '';

            // Re-enable popups (only if not in cross-section mode)
            if (!crossSectionMode) {
                allMarkers.forEach(markerData => {
                    const p = markerData.pointData;
                    const locationName = markerData.locationName;
                    const markerLatlng = markerData.marker.getLatLng();

                    markerData.marker.bindPopup(`
                        <strong>${locationName.replace(/_/g, ' ')}</strong><br/>
                        <strong>Point:</strong> ${p.name}<br/>
                        <strong>Elevation:</strong> ${p.elev} m<br/>
                        <strong>Coordinates:</strong><br/>
                        Northing: ${p.y.toFixed(3)} m<br/>
                        Easting: ${p.x.toFixed(3)} m<br/>
                        Lat/Lon: ${markerLatlng.lat.toFixed(6)}¬∞, ${markerLatlng.lng.toFixed(6)}¬∞
                    `);
                });
            }
        });

        function addSensorPoint(sensorData) {
            sensorPoints.push(sensorData);

            // Create sensor item HTML
            const sensorItem = document.createElement('div');
            sensorItem.className = 'sensor-item';
            const sensorIndex = sensorPoints.length - 1;

            sensorItem.innerHTML = `
                <div class="sensor-header">
                    <strong>${sensorData.type === 'existing' ? sensorData.name : 'Custom Point'}</strong>
                    <div>
                        <button class="edit-sensor" onclick="editSensorElevation(${sensorIndex})">‚úèÔ∏è Edit Elev</button>
                        <button class="remove-sensor" onclick="removeSensor(${sensorIndex})">√ó</button>
                    </div>
                </div>
                <div class="sensor-coords">
                    <div>Lat: ${sensorData.lat.toFixed(6)}¬∞</div>
                    <div>Lon: ${sensorData.lon.toFixed(6)}¬∞</div>
                    <div>UTM X: ${sensorData.x.toFixed(3)} m</div>
                    <div>UTM Y: ${sensorData.y.toFixed(3)} m</div>
                    <div class="sensor-elev-display" id="sensor-elev-${sensorIndex}">
                        <strong>Elevation: <span class="elev-value">${sensorData.elev.toFixed(3)}</span> m</strong>
                    </div>
                    ${sensorData.location ? `<div style="grid-column: 1 / -1;">Location: ${sensorData.location}</div>` : ''}
                </div>
            `;

            document.getElementById('sensorList').appendChild(sensorItem);

            // Add marker on map
            const sensorMarker = L.circleMarker([sensorData.lat, sensorData.lon], {
                radius: 8,
                color: '#FF6B35',
                fillColor: '#FF6B35',
                fillOpacity: 0.8,
                weight: 2
            }).addTo(map);

            sensorMarker.bindPopup(`
                <strong>Sensor Mounting Point</strong><br/>
                ${sensorData.type === 'existing' ? sensorData.name + '<br/>' : ''}
                Elevation: ${sensorData.elev.toFixed(3)} m<br/>
                Lat: ${sensorData.lat.toFixed(6)}¬∞<br/>
                Lon: ${sensorData.lon.toFixed(6)}¬∞
            `);

            sensorMarkers.push(sensorMarker);

            // Exit sensor add mode
            sensorAddMode = false;
            addSensorBtn.classList.remove('active');
            addSensorBtn.innerHTML = 'üìç Add Sensor';
            map.getContainer().style.cursor = '';

            // Re-enable popups (only if not in cross-section mode)
            if (!crossSectionMode) {
                allMarkers.forEach(markerData => {
                    const p = markerData.pointData;
                    const locationName = markerData.locationName;
                    const markerLatlng = markerData.marker.getLatLng();

                    markerData.marker.bindPopup(`
                        <strong>${locationName.replace(/_/g, ' ')}</strong><br/>
                        <strong>Point:</strong> ${p.name}<br/>
                        <strong>Elevation:</strong> ${p.elev} m<br/>
                        <strong>Coordinates:</strong><br/>
                        Northing: ${p.y.toFixed(3)} m<br/>
                        Easting: ${p.x.toFixed(3)} m<br/>
                        Lat/Lon: ${markerLatlng.lat.toFixed(6)}¬∞, ${markerLatlng.lng.toFixed(6)}¬∞
                    `);
                });
            }

            // Update chart and table if cross-section exists
            if (crossSectionPoints.length === 2) {
                renderChart();
                populateReadingsTable();
            }

            // Show panel if not visible
            if (!crossSectionPanel.classList.contains('visible')) {
                crossSectionPanel.style.display = 'block';
                setTimeout(() => {
                    crossSectionPanel.classList.add('visible');
                }, 10);
            }
        }

        // Global function to remove sensor
        window.removeSensor = function(index) {
            if (index < 0 || index >= sensorPoints.length) return;

            // Remove from array
            sensorPoints.splice(index, 1);

            // Remove marker
            if (sensorMarkers[index]) {
                map.removeLayer(sensorMarkers[index]);
                sensorMarkers.splice(index, 1);
            }

            // Rebuild sensor list HTML
            const sensorList = document.getElementById('sensorList');
            sensorList.innerHTML = '';

            sensorPoints.forEach((sensor, i) => {
                const sensorItem = document.createElement('div');
                sensorItem.className = 'sensor-item';

                sensorItem.innerHTML = `
                    <div class="sensor-header">
                        <strong>${sensor.type === 'existing' ? sensor.name : 'Custom Point'}</strong>
                        <div>
                            <button class="edit-sensor" onclick="editSensorElevation(${i})">‚úèÔ∏è Edit Elev</button>
                            <button class="remove-sensor" onclick="removeSensor(${i})">√ó</button>
                        </div>
                    </div>
                    <div class="sensor-coords">
                        <div>Lat: ${sensor.lat.toFixed(6)}¬∞</div>
                        <div>Lon: ${sensor.lon.toFixed(6)}¬∞</div>
                        <div>UTM X: ${sensor.x.toFixed(3)} m</div>
                        <div>UTM Y: ${sensor.y.toFixed(3)} m</div>
                        <div class="sensor-elev-display" id="sensor-elev-${i}">
                            <strong>Elevation: <span class="elev-value">${sensor.elev.toFixed(3)}</span> m</strong>
                        </div>
                        ${sensor.location ? `<div style="grid-column: 1 / -1;">Location: ${sensor.location}</div>` : ''}
                    </div>
                `;

                sensorList.appendChild(sensorItem);
            });

            // Update chart and table if cross-section exists
            if (crossSectionPoints.length === 2) {
                renderChart();
                populateReadingsTable();
            }
        };

        // Global function to edit sensor elevation
        window.editSensorElevation = function(index) {
            if (index < 0 || index >= sensorPoints.length) return;

            const sensor = sensorPoints[index];
            const elevContainer = document.getElementById(`sensor-elev-${index}`);
            
            if (!elevContainer) return;

            // Check if already in edit mode
            if (elevContainer.querySelector('.sensor-elev-input')) {
                return; // Already editing
            }

            const currentElev = sensor.elev;

            // Replace display with input
            elevContainer.innerHTML = `
                <input type="number" class="sensor-elev-input" id="sensor-elev-input-${index}" 
                       value="${currentElev.toFixed(3)}" step="0.001" placeholder="Elevation">
                <button class="edit-sensor" onclick="saveSensorElevation(${index})" style="background: #4CAF50;">‚úì Save</button>
                <button class="edit-sensor" onclick="cancelEditElevation(${index}, ${currentElev})" style="background: #757575;">‚úó Cancel</button>
            `;

            // Focus the input
            const input = document.getElementById(`sensor-elev-input-${index}`);
            if (input) {
                input.focus();
                input.select();

                // Allow Enter key to save
                input.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        saveSensorElevation(index);
                    } else if (e.key === 'Escape') {
                        cancelEditElevation(index, currentElev);
                    }
                });
            }
        };

        // Global function to save sensor elevation
        window.saveSensorElevation = function(index) {
            if (index < 0 || index >= sensorPoints.length) return;

            const input = document.getElementById(`sensor-elev-input-${index}`);
            if (!input) return;

            const newElev = parseFloat(input.value);
            if (isNaN(newElev)) {
                alert('Please enter a valid elevation value');
                return;
            }

            // Update sensor elevation
            sensorPoints[index].elev = newElev;

            // Update display
            const elevContainer = document.getElementById(`sensor-elev-${index}`);
            if (elevContainer) {
                elevContainer.innerHTML = `
                    <strong>Elevation: <span class="elev-value">${newElev.toFixed(3)}</span> m</strong>
                `;
            }

            // Update marker popup
            if (sensorMarkers[index]) {
                const sensor = sensorPoints[index];
                sensorMarkers[index].setPopupContent(`
                    <strong>Sensor Mounting Point</strong><br/>
                    ${sensor.type === 'existing' ? sensor.name + '<br/>' : ''}
                    Elevation: ${sensor.elev.toFixed(3)} m<br/>
                    Lat: ${sensor.lat.toFixed(6)}¬∞<br/>
                    Lon: ${sensor.lon.toFixed(6)}¬∞
                `);
            }

            // Update chart and table if cross-section exists
            if (crossSectionPoints.length === 2) {
                renderChart();
                populateReadingsTable();
            }
        };

        // Global function to cancel elevation edit
        window.cancelEditElevation = function(index, originalElev) {
            const elevContainer = document.getElementById(`sensor-elev-${index}`);
            if (elevContainer) {
                elevContainer.innerHTML = `
                    <strong>Elevation: <span class="elev-value">${originalElev.toFixed(3)}</span> m</strong>
                `;
            }
        };

        // ===== EXPORT/IMPORT FUNCTIONALITY =====

        // Export profile to JSON
        function exportProfile() {
            if (crossSectionPoints.length < 2) {
                alert('No cross-section profile to export. Please create a cross-section first.');
                return;
            }

            const profileData = {
                version: '1.2',
                exportDate: new Date().toISOString(),
                location: selectedLocation,
                perpDistanceThreshold: perpDistanceThreshold,
                crossSectionLine: {
                    start: crossSectionPoints[0],
                    end: crossSectionPoints[1]
                },
                projectedPoints: window.allProjectedPoints || projectedPoints,
                manualPointOverrides: manualPointOverrides,
                sensorPoints: sensorPoints,
                imageOffset: {
                    x: imageOffsetX,
                    y: imageOffsetY
                },
                referenceLine: referenceLinePoints.length === 2 ? {
                    start: referenceLinePoints[0],
                    end: referenceLinePoints[1]
                } : null
            };

            const jsonStr = JSON.stringify(profileData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.href = url;
            link.download = `cross_section_${selectedLocation.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // Import profile from JSON
        function importProfile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const profileData = JSON.parse(e.target.result);

                    // Validate profile data
                    if (!profileData.crossSectionLine || !profileData.location) {
                        throw new Error('Invalid profile file format');
                    }

                    // Clear existing cross-section
                    clearCrossSection();

                    // Restore state
                    selectedLocation = profileData.location;
                    perpDistanceThreshold = profileData.perpDistanceThreshold || 3.0;
                    document.getElementById('perpDistanceInput').value = perpDistanceThreshold;
                    document.getElementById('currentPerpDist').textContent = perpDistanceThreshold.toFixed(1);

                    // Restore cross-section points
                    crossSectionPoints = [
                        profileData.crossSectionLine.start,
                        profileData.crossSectionLine.end
                    ];

                    // Add markers for cross-section points
                    crossSectionPoints.forEach((point, idx) => {
                        const marker = L.marker([point.lat, point.lng], {
                            draggable: true,
                            icon: L.divIcon({
                                className: 'cross-section-marker',
                                html: `<div style="background: #FFA726; width: 16px; height: 16px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 5px rgba(0,0,0,0.5);"></div>`,
                                iconSize: [16, 16],
                                iconAnchor: [8, 8]
                            })
                        }).addTo(map);

                        marker.bindTooltip(idx === 0 ? 'Start (drag to move)' : 'End (drag to move)', {
                            permanent: true,
                            direction: 'top',
                            className: 'elev-label',
                            offset: [0, -10]
                        });

                        const markerIndex = idx;
                        marker.on('dragend', function(e) {
                            const newLatLng = e.target.getLatLng();
                            const utm = proj4(wgs84, utm43n, [newLatLng.lng, newLatLng.lat]);
                            crossSectionPoints[markerIndex].lat = newLatLng.lat;
                            crossSectionPoints[markerIndex].lng = newLatLng.lng;
                            crossSectionPoints[markerIndex].x = utm[0];
                            crossSectionPoints[markerIndex].y = utm[1];
                            updateCrossSectionAfterMove();
                        });

                        crossSectionMarkers.push(marker);
                    });

                    // Draw cross-section line
                    drawCrossSectionLine();

                    // Restore manual overrides
                    manualPointOverrides = profileData.manualPointOverrides || {};

                    // Restore sensor points
                    if (profileData.sensorPoints && profileData.sensorPoints.length > 0) {
                        profileData.sensorPoints.forEach(sensor => {
                            addSensorPoint(sensor);
                        });
                    }

                    // Generate cross-section
                    generateCrossSection();

                    // Restore image offset if present
                    if (profileData.imageOffset) {
                        imageOffsetX = profileData.imageOffset.x || 0;
                        imageOffsetY = profileData.imageOffset.y || 0;
                        offsetXInput.value = imageOffsetX.toFixed(1);
                        offsetYInput.value = imageOffsetY.toFixed(1);
                        
                        // Apply the offset after a short delay to let map settle
                        setTimeout(() => {
                            applyImageOffset(imageOffsetX, imageOffsetY);
                        }, 100);
                    }

                    // Restore reference line if present
                    if (profileData.referenceLine) {
                        clearReferenceLine();
                        referenceLinePoints = [profileData.referenceLine.start, profileData.referenceLine.end];
                        
                        // Add draggable markers for reference line using L.marker with divIcon
                        referenceLinePoints.forEach((point, idx) => {
                            const markerColor = idx === 0 ? '#FF9800' : '#E65100';
                            
                            const icon = L.divIcon({
                                className: 'ref-marker-icon',
                                html: `<div style="width: 16px; height: 16px; background: ${markerColor}; border: 2px solid white; border-radius: 50%; box-shadow: 0 2px 5px rgba(0,0,0,0.3);"></div>`,
                                iconSize: [16, 16],
                                iconAnchor: [8, 8]
                            });
                            
                            const marker = L.marker([point.lat, point.lng], {
                                icon: icon,
                                draggable: true
                            }).addTo(map);
                            
                            marker.bindTooltip(`Ref Point ${idx + 1}`, {
                                permanent: true,
                                direction: 'top',
                                offset: [0, -10]
                            });

                            const markerIndex = idx;
                            marker.on('drag', function(e) {
                                updateReferenceLineOnDrag();
                            });
                            marker.on('dragend', function(e) {
                                const newLatLng = e.target.getLatLng();
                                const utm = proj4(wgs84, utm43n, [newLatLng.lng, newLatLng.lat]);
                                referenceLinePoints[markerIndex].lat = newLatLng.lat;
                                referenceLinePoints[markerIndex].lng = newLatLng.lng;
                                referenceLinePoints[markerIndex].x = utm[0];
                                referenceLinePoints[markerIndex].y = utm[1];
                                updateAngleComparison();
                            });
                            
                            referenceLineMarkers.push(marker);
                        });

                        drawReferenceLine();
                    }

                    // Fit map to cross-section
                    const bounds = L.latLngBounds([
                        [crossSectionPoints[0].lat, crossSectionPoints[0].lng],
                        [crossSectionPoints[1].lat, crossSectionPoints[1].lng]
                    ]);
                    map.fitBounds(bounds.pad(0.3));

                    const offsetInfo = profileData.imageOffset && (profileData.imageOffset.x !== 0 || profileData.imageOffset.y !== 0)
                        ? `\nImage Offset: X=${imageOffsetX.toFixed(1)}m, Y=${imageOffsetY.toFixed(1)}m`
                        : '';
                    const refLineInfo = profileData.referenceLine ? '\nReference line: Restored' : '';
                    alert(`Profile imported successfully!\nLocation: ${selectedLocation}\nPoints: ${(window.allProjectedPoints || []).length}${offsetInfo}${refLineInfo}`);

                } catch (error) {
                    console.error('Import error:', error);
                    alert('Error importing profile: ' + error.message);
                }
            };

            reader.readAsText(file);
            event.target.value = ''; // Reset file input
        }

        // Export to PDF
        async function exportToPDF() {
            if (crossSectionPoints.length < 2) {
                alert('No cross-section profile to export. Please create a cross-section first.');
                return;
            }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('landscape', 'mm', 'a4');

            const pageWidth = doc.internal.pageSize.getWidth();
            const pageHeight = doc.internal.pageSize.getHeight();
            const margin = 15;

            // Title
            doc.setFontSize(18);
            doc.setFont('helvetica', 'bold');
            doc.text('Cross Section Profile Report', pageWidth / 2, margin, { align: 'center' });

            // Location and Date
            doc.setFontSize(12);
            doc.setFont('helvetica', 'normal');
            doc.text(`Location: ${selectedLocation}`, margin, margin + 10);
            doc.text(`Date: ${new Date().toLocaleDateString()}`, pageWidth - margin, margin + 10, { align: 'right' });

            // Profile Info
            doc.setFontSize(10);
            const lineLength = Math.sqrt(
                Math.pow(crossSectionPoints[1].x - crossSectionPoints[0].x, 2) +
                Math.pow(crossSectionPoints[1].y - crossSectionPoints[0].y, 2)
            );

            const activePoints = (window.allProjectedPoints || []).filter(p => {
                const pointKey = `${p.name}_${p.originalElevation.toFixed(3)}`;
                return manualPointOverrides[pointKey] !== false;
            });

            doc.text(`Section Length: ${lineLength.toFixed(2)} m`, margin, margin + 18);
            doc.text(`Active Points: ${activePoints.length}`, margin + 80, margin + 18);
            doc.text(`Perpendicular Distance: ${perpDistanceThreshold} m`, margin + 160, margin + 18);

            // Cross-section line coordinates
            doc.text(`Start: UTM ${crossSectionPoints[0].x.toFixed(3)} E, ${crossSectionPoints[0].y.toFixed(3)} N`, margin, margin + 25);
            doc.text(`End: UTM ${crossSectionPoints[1].x.toFixed(3)} E, ${crossSectionPoints[1].y.toFixed(3)} N`, margin + 120, margin + 25);

            // Capture chart as image
            try {
                const chartCanvas = document.getElementById('crossSectionChart');
                const chartImage = chartCanvas.toDataURL('image/png', 1.0);
                doc.addImage(chartImage, 'PNG', margin, margin + 32, pageWidth - 2 * margin, 70);
            } catch (e) {
                console.error('Error capturing chart:', e);
            }

            // Table data
            const tableData = activePoints.map((point, idx) => {
                const minElev = Math.min(...activePoints.map(p => p.originalElevation));
                return [
                    idx + 1,
                    point.name,
                    point.distanceAlong.toFixed(2),
                    point.originalElevation.toFixed(3),
                    (point.originalElevation - minElev).toFixed(3),
                    point.originalX ? point.originalX.toFixed(3) : '-',
                    point.originalY ? point.originalY.toFixed(3) : '-'
                ];
            });

            // Add sensor points to table
            if (sensorPoints.length > 0) {
                const minElev = activePoints.length > 0 ? Math.min(...activePoints.map(p => p.originalElevation)) : 0;
                sensorPoints.forEach((sensor, idx) => {
                    const projected = projectSensorOntoLine(
                        sensor,
                        crossSectionPoints[0],
                        crossSectionPoints[1]
                    );
                    tableData.push([
                        'S' + (idx + 1),
                        sensor.name || 'Custom Sensor',
                        projected.distanceAlong.toFixed(2),
                        sensor.elev.toFixed(3),
                        (sensor.elev - minElev).toFixed(3),
                        sensor.x.toFixed(3),
                        sensor.y.toFixed(3)
                    ]);
                });
            }

            // Add table
            doc.autoTable({
                startY: margin + 105,
                head: [['#', 'Point Name', 'Distance (m)', 'Elevation (m)', 'Normalized (m)', 'UTM X (m)', 'UTM Y (m)']],
                body: tableData,
                theme: 'grid',
                styles: { fontSize: 8, cellPadding: 1.5 },
                headStyles: { fillColor: [33, 150, 243], textColor: 255 },
                alternateRowStyles: { fillColor: [245, 245, 245] },
                margin: { left: margin, right: margin }
            });

            // Footer
            const finalY = doc.lastAutoTable.finalY || pageHeight - 10;
            doc.setFontSize(8);
            doc.text(`Generated by DGPS Survey Tool - ${new Date().toLocaleString()}`, pageWidth / 2, Math.min(finalY + 10, pageHeight - 5), { align: 'center' });

            // Save PDF
            doc.save(`cross_section_${selectedLocation.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.pdf`);
        }

        // Export to Excel
        function exportToExcel() {
            if (crossSectionPoints.length < 2) {
                alert('No cross-section profile to export. Please create a cross-section first.');
                return;
            }

            const activePoints = (window.allProjectedPoints || []).filter(p => {
                const pointKey = `${p.name}_${p.originalElevation.toFixed(3)}`;
                return manualPointOverrides[pointKey] !== false;
            });

            const minElev = activePoints.length > 0 ? Math.min(...activePoints.map(p => p.originalElevation)) : 0;
            const lineLength = Math.sqrt(
                Math.pow(crossSectionPoints[1].x - crossSectionPoints[0].x, 2) +
                Math.pow(crossSectionPoints[1].y - crossSectionPoints[0].y, 2)
            );

            // Create workbook
            const wb = XLSX.utils.book_new();

            // Sheet 1: Profile Summary
            const summaryData = [
                ['CROSS SECTION PROFILE REPORT'],
                [],
                ['Location', selectedLocation],
                ['Export Date', new Date().toLocaleString()],
                ['Section Length (m)', lineLength.toFixed(2)],
                ['Active Points', activePoints.length],
                ['Perpendicular Distance Threshold (m)', perpDistanceThreshold],
                [],
                ['CROSS-SECTION LINE'],
                ['', 'Latitude', 'Longitude', 'UTM X (Easting)', 'UTM Y (Northing)'],
                ['Start Point', crossSectionPoints[0].lat.toFixed(6), crossSectionPoints[0].lng.toFixed(6), crossSectionPoints[0].x.toFixed(3), crossSectionPoints[0].y.toFixed(3)],
                ['End Point', crossSectionPoints[1].lat.toFixed(6), crossSectionPoints[1].lng.toFixed(6), crossSectionPoints[1].x.toFixed(3), crossSectionPoints[1].y.toFixed(3)]
            ];

            const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
            summarySheet['!cols'] = [{ wch: 30 }, { wch: 15 }, { wch: 15 }, { wch: 18 }, { wch: 18 }];
            XLSX.utils.book_append_sheet(wb, summarySheet, 'Summary');

            // Sheet 2: DGPS Points
            const pointsData = [
                ['#', 'Point Name', 'Distance from Start (m)', 'Original Elevation (m)', 'Normalized Elevation (m)', 'Perpendicular Dist (m)', 'UTM X - Easting (m)', 'UTM Y - Northing (m)', 'Status']
            ];

            const allPoints = window.allProjectedPoints || [];
            allPoints.forEach((point, idx) => {
                const pointKey = `${point.name}_${point.originalElevation.toFixed(3)}`;
                const isIncluded = manualPointOverrides[pointKey] !== false;
                pointsData.push([
                    idx + 1,
                    point.name,
                    point.distanceAlong.toFixed(3),
                    point.originalElevation.toFixed(3),
                    (point.originalElevation - minElev).toFixed(3),
                    point.perpendicularDistance.toFixed(3),
                    point.originalX ? point.originalX.toFixed(3) : '',
                    point.originalY ? point.originalY.toFixed(3) : '',
                    isIncluded ? 'Active' : 'Excluded'
                ]);
            });

            const pointsSheet = XLSX.utils.aoa_to_sheet(pointsData);
            pointsSheet['!cols'] = [
                { wch: 5 }, { wch: 25 }, { wch: 20 }, { wch: 18 }, { wch: 20 },
                { wch: 18 }, { wch: 20 }, { wch: 20 }, { wch: 10 }
            ];
            XLSX.utils.book_append_sheet(wb, pointsSheet, 'DGPS Points');

            // Sheet 3: Sensor Points (if any)
            if (sensorPoints.length > 0) {
                const sensorData = [
                    ['#', 'Sensor Name', 'Type', 'Distance from Start (m)', 'Elevation (m)', 'Normalized (m)', 'Latitude', 'Longitude', 'UTM X (m)', 'UTM Y (m)', 'Location']
                ];

                sensorPoints.forEach((sensor, idx) => {
                    const projected = projectSensorOntoLine(
                        sensor,
                        crossSectionPoints[0],
                        crossSectionPoints[1]
                    );

                    sensorData.push([
                        idx + 1,
                        sensor.name || 'Custom Sensor',
                        sensor.type,
                        projected.distanceAlong.toFixed(3),
                        sensor.elev.toFixed(3),
                        (sensor.elev - minElev).toFixed(3),
                        sensor.lat.toFixed(6),
                        sensor.lon.toFixed(6),
                        sensor.x.toFixed(3),
                        sensor.y.toFixed(3),
                        sensor.location || ''
                    ]);
                });

                const sensorSheet = XLSX.utils.aoa_to_sheet(sensorData);
                sensorSheet['!cols'] = [
                    { wch: 5 }, { wch: 20 }, { wch: 10 }, { wch: 20 }, { wch: 12 },
                    { wch: 12 }, { wch: 14 }, { wch: 14 }, { wch: 14 }, { wch: 14 }, { wch: 20 }
                ];
                XLSX.utils.book_append_sheet(wb, sensorSheet, 'Sensor Points');
            }

            // Sheet 4: Chart Data (for recreating chart)
            const chartData = [
                ['Distance from Start (m)', 'Normalized Elevation (m)', 'Original Elevation (m)', 'Point Name']
            ];

            activePoints.forEach(point => {
                chartData.push([
                    point.distanceAlong.toFixed(3),
                    (point.originalElevation - minElev).toFixed(3),
                    point.originalElevation.toFixed(3),
                    point.name
                ]);
            });

            const chartSheet = XLSX.utils.aoa_to_sheet(chartData);
            chartSheet['!cols'] = [{ wch: 22 }, { wch: 22 }, { wch: 20 }, { wch: 25 }];
            XLSX.utils.book_append_sheet(wb, chartSheet, 'Chart Data');

            // Save Excel file
            XLSX.writeFile(wb, `cross_section_${selectedLocation.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.xlsx`);
        }

    </script>
</body>
</html>
